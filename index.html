<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billard Turnierplan (16 Spieler) - PWA</title>
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Billard Turnier">
    <meta name="theme-color" content="#f4f4f4">

    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        h1, h2, h3 { color: #0056b3; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; background-color: #fff; box-shadow: 0 2px 3px rgba(0,0,0,0.1); }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #e2e2e2; }
        .group-table td:first-child, .group-table th:first-child { text-align: left; }
        .player-list td:first-child { text-align: left; }

        /* NEU: Flexbox für den Hauptcontainer der Gruppen */
        .all-groups-container {
            display: flex;
            flex-wrap: wrap; /* Erlaubt Umbruch auf kleineren Bildschirmen */
            gap: 20px; /* Abstand zwischen den Gruppen */
            justify-content: center; /* Zentriert die Gruppen */
        }

        /* Flexbox für Gruppen-Sektionen */
        .group-section {
            display: flex;
            flex-wrap: wrap; /* Erlaubt Umbruch auf kleineren Bildschirmen */
            gap: 20px;
            margin-bottom: 0; /* Entferne den unteren Margin, da der Elterncontainer Gap hat */
            align-items: flex-start;
            /* NEU: Grundbreite für jede Gruppe, die zwei nebeneinander erlaubt */
            flex: 1 1 calc(50% - 10px); /* Nimmt 50% Breite minus halbem Gap */
            min-width: 450px; /* Mindestbreite, damit der Inhalt nicht zu stark schrumpft */
            max-width: calc(50% - 10px); /* Maximal 50% abzüglich Gap */
        }
        /* Sicherstellen, dass der H2-Titel einer Gruppe über der Gruppe selbst ist */
        .group-header {
            width: 100%; /* H2 nimmt volle Breite */
            margin-bottom: 10px; /* Abstand zum Gruppen-Container */
            margin-top: 20px; /* Abstand zum vorherigen Element */
        }
        .group-header h2 {
             margin-top: 0;
        }

        /* NEU: Container für Matchliste und Billardtisch */
        .group-primary-display {
            display: flex; /* Macht die Kinder (Matchliste, Billardtisch) zu Flex-Items */
            flex-wrap: wrap; /* Erlaubt Umbruch, falls kein Platz */
            gap: 20px; /* Abstand zwischen Matchliste und Billardtisch */
            flex: 2; /* Nimmt mehr Platz ein als group-details, wenn vorhanden */
            min-width: 600px; /* Mindestbreite für dieses Duo */
            align-items: flex-start; /* Oben ausrichten */
        }

        .group-details {
            flex: 1; /* Nimmt verfügbaren Platz ein, aber weniger als group-primary-display */
            min-width: 320px; /* Mindestbreite für Details (Tabelle) */
        }

        .group-matches-list {
            flex: 1; /* Nimmt verfügbaren Platz im group-primary-display ein */
            min-width: 280px; /* Mindestbreite für Matchliste */
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 3px rgba(0,0,0,0.1);
        }
        .group-matches-list h3 {
            margin-top: 0;
            color: #007bff;
        }
        .group-match-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed #eee;
            position: relative; /* Für die Markierung des nächsten Spiels */
        }
        .group-match-item:last-child {
            border-bottom: none;
        }
        .group-match-item .players {
            font-weight: bold;
            color: #333;
            flex-grow: 1; /* Lässt Spieler-Namen den meisten Platz einnehmen */
            text-align: left;
        }
        .group-match-item .result-display {
            font-style: italic;
            color: #555;
            min-width: 50px; /* Platz für Ergebnis */
            text-align: right;
            cursor: pointer; /* Damit der Bereich klickbar ist */
            padding: 2px 5px; /* Klickfläche vergrößern */
            border: 1px solid transparent; /* Rahmen für Klickbarkeit */
            border-radius: 3px;
        }
        .group-match-item .result-display:hover {
            background-color: #f0f0f0;
            border-color: #ccc;
        }
        .group-match-item.played .players {
            text-decoration: line-through;
            color: #888;
        }
        .group-match-item.played .result-display {
            color: #888;
            background-color: #e9e9e9;
        }

        /* NEU: Stil für das nächste anstehende Spiel in der Gruppenliste */
        .group-match-item.next-up {
            background-color: #fffacd; /* Light yellow */
            border: 2px solid #ffd700; /* Gold border */
            padding: 8px 10px; /* etwas mehr padding */
            border-radius: 5px;
            margin: 5px 0;
        }

        /* NEU: Stil für den Billardtisch */
        .group-billiard-table {
            flex-shrink: 0; /* Verhindert, dass der Tisch schrumpft */
            width: 150px; /* Feste Breite */
            height: 290px; /* Feste Höhe */
            background-color: #006400; /* Dunkelgrün für Billardtuch */
            border: 10px solid #8B4513; /* Brauner Rahmen für den Tisch */
            border-radius: 15px; /* Leicht abgerundete Ecken */
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column; /* Spieler untereinander */
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            padding: 10px;
            box-sizing: border-box; /* Padding in die Breite/Höhe einbeziehen */
        }

        .group-billiard-table .table-title {
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #aaddaa;
        }

        .group-billiard-table .player-on-table {
            font-size: 1.1em;
            margin: 3px 0;
            padding: 2px 5px;
            background-color: rgba(255,255,255,0.1); /* Leicht transparenter Hintergrund für Namen */
            border-radius: 3px;
        }
        .group-billiard-table .player-on-table:empty::before {
            content: "Wartet..."; /* Platzhalter, wenn kein Spieler da ist */
            color: rgba(255,255,255,0.5);
        }

        .knockout-bracket {
            display: flex;
            justify-content: center; /* Zentriert die Spalten */
            align-items: flex-start;
            flex-wrap: wrap; /* Erlaubt Umbruch */
            gap: 20px; /* Abstand zwischen den Spalten */
        }
        .round-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 250px; /* Mindestbreite für jede Runde */
            flex: 1; /* Gleichmäßige Verteilung des Platzes */
            max-width: 280px; /* Maximale Breite für jede Runde */
        }
        .match {
            border: 1px solid #ccc;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            background-color: #f9f9f9;
            width: 100%; /* Passt sich der Spaltenbreite an */
            max-width: 220px; /* Begrenzung der Match-Box Breite */
            text-align: center;
            box-sizing: border-box;
            position: relative;
        }
        .match-label { font-weight: bold; margin-bottom: 5px; color: #555; }
        .player-name { margin-bottom: 3px; min-height: 1.2em; font-weight: bold;}
        .vs { font-style: italic; color: #666; margin: 2px 0; }
        /* Stil für Ergebnis-Zellen in K.O.-Phase (Gewinner) */
        .winner.result-cell {
            width: auto; /* An Inhalt anpassen */
            height: auto;
            min-height: 1.2em; /* Wie player-name */
            font-weight: bold;
            color: green;
            margin-top: 5px;
            cursor: pointer;
            border: 1px solid #ccc; /* Rahmen wie bei Gruppenphase */
            display: flex; /* Für Zentrierung des Textes */
            align-items: center;
            justify-content: center;
            padding: 2px 5px; /* Etwas Padding */
        }
        .winner.result-cell:empty {
            background-color: #e0ffe0; /* Hellgrüner Hintergrund für leere Gewinner-Felder */
        }
        .winner.result-cell.played {
            text-decoration: none; /* Gewinner sollen nicht durchgestrichen werden */
            color: green;
            background-color: #d4edda; /* Etwas dunkler, wenn Ergebnis da ist */
        }
        .winner.result-cell:hover:not(.played) {
            background-color: #f0f8ff; /* Sehr hellblau bei Hover */
        }

        .final-winner { font-size: 1.5em; font-weight: bold; color: #d9534f; margin-top: 40px; text-align: center; width: 100%; }
        .instructions ol { list-style-type: decimal; padding-left: 20px; }
        .instructions li { margin-bottom: 5px; }

        .qualify-button, .setup-players-button {
            display: block;
            margin: 20px auto;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            text-decoration: none;
            max-width: 300px; /* Button nicht zu breit machen */
        }
        .qualify-button:hover, .setup-players-button:hover {
            background-color: #0056b3;
        }

        /* NEU: Toggle-Funktionalität für Sektionen */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            color: #FFFFFF;
            background-color: #C46767; /* Leichter Hintergrund für Header */
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid #91d5ff;
        }
        .collapsible-header h2 {
            margin: 0;
            color: #FFFFFF;
        }
        .toggle-icon {
            font-size: 1.5em;
            transition: transform 0.3s ease;
        }
        .collapsible-header.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        .collapsible-content {
            display: none;
            overflow: hidden;
            max-height: 0; /* Startwert für Transition */
            transition: max-height 0.5s ease-in-out; /* Weicherer Übergang */
            padding-bottom: 20px; /* Abstand nach Sektion, wenn geöffnet */
        }
        .collapsible-header.expanded + .collapsible-content {
            display: block; /* Wichtig: setzt display auf block, damit max-height wirkt */
            max-height: 1000px; /* Genug Platz für Inhalt, höher als erwarteter Inhalt */
        }

        .player-input-area textarea {
            width: 100%;
            max-width: 500px; /* Begrenzung für bessere Lesbarkeit */
            height: 150px; /* Etwas höher für 16 Namen */
            padding: 10px;
            font-size: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        /* Die 'Nächste Spiele' Sektion wird nun nur noch die Gesamtübersicht ungespielter Matches darstellen */
        .next-games-section {
            background-color: #e6f7ff;
            border: 1px solid #91d5ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px; /* Angepasster Margin-Top */
        }
        .next-game-item {
            padding: 8px 0;
            border-bottom: 1px dashed #cceeff;
        }
        .next-game-item:last-child {
            border-bottom: none;
        }
        .next-game-player {
            font-weight: bold;
            color: #0056b3;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6); /* Dunklerer Hintergrund */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px; /* Mehr Padding */
            border: 1px solid #888;
            width: 90%; /* Etwas breiter auf kleineren Screens */
            max-width: 450px; /* Maximale Breite */
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); /* Stärkerer Schatten */
            text-align: center;
            position: relative;
        }
        .modal-content h3 {
            margin-top: 0;
            color: #0056b3;
            margin-bottom: 20px;
        }
        
        /* Adjusted Styles for Score Input with Arrows */
        .score-input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 15px 0;
            gap: 10px; /* Reduced gap for a more compact look */
        }
        .score-input-group .player-score-controls {
            display: flex;
            align-items: center;
            gap: 5px; /* Smaller gap between button and input */
            border: 1px solid #dcdcdc; /* Subtle border around controls */
            border-radius: 5px;
            padding: 2px; /* Inner padding for the group */
            background-color: #f9f9f9; /* Light background */
        }
        .score-input-group button {
            background-color: #e0e0e0; /* Lighter grey for buttons */
            color: #333; /* Darker text for contrast */
            border: none;
            border-radius: 4px; /* Slightly smaller border radius */
            padding: 4px 8px; /* Smaller padding for a more discreet look */
            font-size: 1.1em; /* Slightly smaller font */
            cursor: pointer;
            flex-shrink: 0;
            transition: background-color 0.2s ease;
        }
        .score-input-group button:hover {
            background-color: #d0d0d0; /* Darker grey on hover */
        }
        .score-input-group input[type="number"] {
            width: 50px; /* More compact width */
            padding: 6px; /* Reduced padding */
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em; /* Standard font size */
            text-align: center;
            -moz-appearance: textfield;
            background-color: #fff;
        }
        /* Hide default arrows in Chrome/Safari/Edge */
        .score-input-group input[type=number]::-webkit-inner-spin-button,
        .score-input-group input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .modal-content .modal-vs {
            font-size: 1.1em; /* Slightly smaller font */
            font-weight: normal; /* Less bold */
            margin: 0 10px; /* Reduced margin */
            min-width: 20px; /* Smaller min-width */
            color: #666; /* More subtle color */
        }

        /* NEU: Styles for clickable winner names in KO modal */
        .knockout-winner-selection {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        .knockout-winner-selection .winner-option {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            background-color: #e6f7ff; /* Light blue background */
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .knockout-winner-selection .winner-option:hover {
            background-color: #cceeff; /* Darker blue on hover */
            border-color: #91d5ff;
        }
        .knockout-winner-selection .winner-option.selected {
            background-color: #28a745; /* Green for selected */
            color: white;
            border-color: #218838;
        }
        .knockout-winner-selection .winner-option.selected:hover {
            background-color: #218838;
        }


        .modal-content button.save-button { /* Spezifischer für den Speichern-Button */
            background-color: #28a745;
            color: white;
            padding: 12px 20px; /* Größerer Button */
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            margin-top: 25px; /* Mehr Abstand */
        }
        .modal-content button.save-button:hover {
            background-color: #218838;
        }
        .close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #aaa;
            font-size: 32px; /* Größer für leichtere Klickbarkeit */
            font-weight: bold;
            cursor: pointer;
        }
        .close-button:hover,
        .close-button:focus {
            color: #333;
            text-decoration: none;
        }

        /* Media Queries for Responsiveness */
        @media (max-width: 1300px) { /* Anpassen für 2 Spalten Layout */
            .group-section {
                flex: 1 1 100%; /* Jede Gruppe nimmt volle Breite */
                max-width: 100%;
                min-width: unset; /* Mindestbreite zurücksetzen */
            }
            .all-groups-container {
                gap: 0; /* Kein Gap mehr im container, da section selbst den Margin unten hat */
            }
            .group-section {
                margin-bottom: 40px; /* Füge Margin unten wieder hinzu */
            }
        }
        @media (max-width: 768px) {
            .group-section {
                flex-direction: column; /* Stapelt Gruppen-Details unter Matchliste */
                align-items: stretch; /* Volle Breite */
            }
            .group-primary-display { /* Auch diesen Container stapeln, wenn section gestapelt ist */
                flex-direction: column;
                min-width: unset; /* Mindestbreite zurücksetzen */
                width: 100%;
                flex: none;
            }
            .group-details, .group-matches-list, .group-billiard-table {
                min-width: unset; /* Setzt Mindestbreite zurück */
                width: 100%; /* Volle Breite */
                flex: none; /* Keine Flex-Schrumpfung/Wachstum */
            }
            .knockout-bracket {
                flex-direction: column; /* Stapelt K.O.-Runden untereinander */
                align-items: center;
            }
            .round-column {
                min-width: unset;
                width: 95%; /* Etwas Abstand am Rand */
                max-width: 350px; /* Begrenzt die Breite auf kleineren Geräten */
            }
            .match {
                max-width: 100%; /* Match-Box nimmt volle Breite der Spalte ein */
            }
            .modal-content {
                width: 95%;
                padding: 20px;
            }
        }
        @media (max-width: 480px) {
            body { margin: 10px; }
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.4em; }
            /* The score input group is already horizontal,
               but if it needs to stack on very small screens,
               this would be the place for it.
               Currently, it should remain horizontal due to reduced gaps. */
            /* .score-input-group {
                flex-direction: column;
                gap: 10px;
            } */
            .modal-content .modal-vs {
                margin: 5px 0; /* Reduced margin for very small screens */
            }
        }
    </style>
</head>
<body>
    <h1>Billard Turnierplan (16 Spieler)</h1>

    <div class="collapsible-header collapsed" onclick="toggleSection('instructionsSection')">
        <span class="toggle-icon">&#9660;</span><h2>Anleitung & Turnierinfos</h2>
    </div>
    <div id="instructionsSection" class="collapsible-content">
        <div class="instructions">
            <ol>
                <li>Klicke auf "Spieler einrichten", um das Eingabefeld zu öffnen. Trage alle 16 Spielernamen (jeder Name in einer neuen Zeile) ein. Klicke dann auf "Spieler einrichten & Gruppen zuweisen".</li>
                <li>In den Gruppen-Sektionen siehst du die Liste der Matches pro Gruppe. Das **nächste anstehende Spiel ist gelb hervorgehoben**. Klicke auf das Ergebnisfeld eines Matches, um das Ergebnis einzutragen (z.B. '3:1' oder mit den Pfeilen). Gespielte Matches werden durchgestrichen. Die Spieler des nächsten Matches erscheinen auf dem **virtuellen Billardtisch** neben der Matchliste.</li>
                <li>Wenn alle Gruppenspiele beendet sind, klicke den Button "Qualifizierte Spieler zur K.O.-Phase hinzufügen".</li>
                <li>Trage dann die Gewinner der K.O.-Matches ein, indem du auf das leere Gewinnerfeld klickst. **Wähle den Gewinner einfach per Klick im Modal aus.** Sie rücken automatisch in die nächste Runde vor.</li>
                <li>Klicke auf den Titel "Nächste Spiele (Gesamtübersicht)", um alle noch unvollständigen Matches anzuzeigen.</li>
            </ol>
            <h3>Regeln:</h3>
            <ul>
                <li><strong>Punkte:</strong> 2 Punkte für Sieg, 0 Punkte für Niederlage</li>
                <li><strong>Tie-Breaker (bei Punktgleichheit):</strong> 1. Punkte, 2. Frame-Differenz, 3. Mehr gewonnene Frames. (Direkter Vergleich ist nicht automatisiert)</li>
            </ul>
        </div>
    </div>

    ---

    <div class="collapsible-header collapsed" onclick="toggleSection('playerSetupSection')">
        <span class="toggle-icon">&#9660;</span><h2>Spieler einrichten</h2>
    </div>
    <div id="playerSetupSection" class="collapsible-content">
        <div class="player-input-area">
            <label for="playerNamesInput">Trage 16 Spielernamen ein (jeder Name in einer neuen Zeile):</label><br>
            <textarea id="playerNamesInput" rows="10" placeholder="Spieler 1&#10;Spieler 2&#10;...&#10;Spieler 16"></textarea>
            <button class="setup-players-button" onclick="setupPlayersAndGroups()">Spieler einrichten & Gruppen zuweisen</button>
        </div>
        <h2>Zugewiesene Spieler & Gruppen</h2>
        <table id="assignedPlayerList" class="player-list">
            <thead>
                <tr>
                    <th>Spieler-ID</th>
                    <th>Name</th>
                    <th>Gruppe</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </div>

    ---

    <div class="all-groups-container">
        <div>
            <div class="group-header"><h2>Gruppe A</h2></div>
            <div class="group-section">
                <div class="group-primary-display">
                    <div class="group-matches-list" id="groupA_matches_list">
                        <h3>Spiele Gruppe A</h3>
                    </div>
                    <div class="group-billiard-table" id="groupA_billiard_table">
                        <div class="table-title">Aktuelles Spiel auf Tisch A</div>
                        <div class="player-on-table" id="groupA_player1_on_table"></div>
                        <div class="player-on-table" id="groupA_player2_on_table"></div>
                    </div>
                </div>
                <div class="group-details">
                    <h3>Rangliste Gruppe A</h3>
                    <table class="group-table" id="groupA_ranking">
                        <thead>
                            <tr>
                                <th style="width: 50px;">Rang</th>
                                <th>Spieler</th>
                                <th>Spiele</th>
                                <th>Siege</th>
                                <th>Niederlagen</th>
                                <th>Frames+</th>
                                <th>Frames-</th>
                                <th>Diff.</th>
                                <th>Punkte</th>
                            </tr>
                        </thead>
                        <tbody>
                            </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div>
            <div class="group-header"><h2>Gruppe B</h2></div>
            <div class="group-section">
                <div class="group-primary-display">
                    <div class="group-matches-list" id="groupB_matches_list">
                        <h3>Spiele Gruppe B</h3>
                    </div>
                    <div class="group-billiard-table" id="groupB_billiard_table">
                        <div class="table-title">Aktuelles Spiel auf Tisch B</div>
                        <div class="player-on-table" id="groupB_player1_on_table"></div>
                        <div class="player-on-table" id="groupB_player2_on_table"></div>
                    </div>
                </div>
                <div class="group-details">
                    <h3>Rangliste Gruppe B</h3>
                    <table class="group-table" id="groupB_ranking">
                        <thead>
                            <tr>
                                <th style="width: 50px;">Rang</th>
                                <th>Spieler</th>
                                <th>Spiele</th>
                                <th>Siege</th>
                                <th>Niederlagen</th>
                                <th>Frames+</th>
                                <th>Frames-</th>
                                <th>Diff.</th>
                                <th>Punkte</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div>
            <div class="group-header"><h2>Gruppe C</h2></div>
            <div class="group-section">
                <div class="group-primary-display">
                    <div class="group-matches-list" id="groupC_matches_list">
                        <h3>Spiele Gruppe C</h3>
                    </div>
                    <div class="group-billiard-table" id="groupC_billiard_table">
                        <div class="table-title">Aktuelles Spiel auf Tisch C</div>
                        <div class="player-on-table" id="groupC_player1_on_table"></div>
                        <div class="player-on-table" id="groupC_player2_on_table"></div>
                    </div>
                </div>
                <div class="group-details">
                    <h3>Rangliste Gruppe C</h3>
                    <table class="group-table" id="groupC_ranking">
                        <thead>
                            <tr>
                                <th style="width: 50px;">Rang</th>
                                <th>Spieler</th>
                                <th>Spiele</th>
                                <th>Siege</th>
                                <th>Niederlagen</th>
                                <th>Frames+</th>
                                <th>Frames-</th>
                                <th>Diff.</th>
                                <th>Punkte</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div>
            <div class="group-header"><h2>Gruppe D</h2></div>
            <div class="group-section">
                <div class="group-primary-display">
                    <div class="group-matches-list" id="groupD_matches_list">
                        <h3>Spiele Gruppe D</h3>
                    </div>
                    <div class="group-billiard-table" id="groupD_billiard_table">
                        <div class="table-title">Aktuelles Spiel auf Tisch D</div>
                        <div class="player-on-table" id="groupD_player1_on_table"></div>
                        <div class="player-on-table" id="groupD_player2_on_table"></div>
                    </div>
                </div>
                <div class="group-details">
                    <h3>Rangliste Gruppe D</h3>
                    <table class="group-table" id="groupD_ranking">
                        <thead>
                            <tr>
                                <th style="width: 50px;">Rang</th>
                                <th>Spieler</th>
                                <th>Spiele</th>
                                <th>Siege</th>
                                <th>Niederlagen</th>
                                <th>Frames+</th>
                                <th>Frames-</th>
                                <th>Diff.</th>
                                <th>Punkte</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    ---

    <div class="collapsible-header collapsed" onclick="toggleSection('nextGamesSectionWrapper')">
        <span class="toggle-icon">&#9660;</span><h2>Nächste Spiele (Gesamtübersicht)</h2>
    </div>
    <div id="nextGamesSectionWrapper" class="collapsible-content">
        <div class="next-games-section" id="nextGamesSection">
            <p>Aktuell keine ungespielten Matches in der Gruppenphase.</p>
        </div>
    </div>

    ---

    <h2>K.O.-Phase: Viertelfinale, Halbfinale, Finale</h2>
    <button class="qualify-button" onclick="qualifyGroupWinners()">Qualifizierte Spieler zur K.O.-Phase hinzufügen</button>
    <div class="knockout-bracket">
        <div class="round-column">
            <h3>Viertelfinale</h3>
            <div class="match" id="vf_match1">
                <div class="match-label">Match 1</div>
                <div class="player-name" id="vf1_player1"></div>
                <div class="vs">vs.</div>
                <div class="player-name" id="vf1_player2"></div>
                <span class="winner result-cell" data-match-id="vf1"></span>
            </div>
            <div class="match" id="vf_match2">
                <div class="match-label">Match 2</div>
                <div class="player-name" id="vf2_player1"></div>
                <div class="vs">vs.</div>
                <div class="player-name" id="vf2_player2"></div>
                <span class="winner result-cell" data-match-id="vf2"></span>
            </div>
        </div>

        <div class="round-column">
            <h3>Viertelfinale</h3>
            <div class="match" id="vf_match3">
                <div class="match-label">Match 3</div>
                <div class="player-name" id="vf3_player1"></div>
                <div class="vs">vs.</div>
                <div class="player-name" id="vf3_player2"></div>
                <span class="winner result-cell" data-match-id="vf3"></span>
            </div>
            <div class="match" id="vf_match4">
                <div class="match-label">Match 4</div>
                <div class="player-name" id="vf4_player1"></div>
                <div class="vs">vs.</div>
                <div class="player-name" id="vf4_player2"></div>
                <span class="winner result-cell" data-match-id="vf4"></span>
            </div>
        </div>

        <div class="round-column">
            <h3>Halbfinale</h3>
            <div class="match" id="hf_match1">
                <div class="match-label">Halbfinale 1</div>
                <div class="player-name" id="hf1_player1"></div>
                <div class="vs">vs.</div>
                <div class="player-name" id="hf1_player2"></div>
                <span class="winner result-cell" data-match-id="hf1"></span>
            </div>
            <div class="match" id="hf_match2">
                <div class="match-label">Halbfinale 2</div>
                <div class="player-name" id="hf2_player1"></div>
                <div class="vs">vs.</div>
                <div class="player-name" id="hf2_player2"></div>
                <span class="winner result-cell" data-match-id="hf2"></span>
            </div>
        </div>

        <div class="round-column">
            <h3>Finale</h3>
            <div class="match" id="final_match">
                <div class="match-label">Finale</div>
                <div class="player-name" id="final_player1"></div>
                <div class="vs">vs.</div>
                <div class="player-name" id="final_player2"></div>
                <span class="winner result-cell" data-match-id="final"></span>
            </div>
        </div>

        <div class="final-winner">
            <h3>TURNIERSIEGER: <span id="tournament_champion"></span></h3>
        </div>
    </div>

    <div id="resultModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal()">&times;</span>
            <h3>Ergebnis eingeben</h3>
            <p><span id="modalPlayer1"></span> <span class="modal-vs">vs.</span> <span id="modalPlayer2"></span></p>
            
            <div class="score-input-group" id="groupPhaseScoreInput">
                <div class="player-score-controls">
                    <button onclick="changeScore('score1', -1)">-</button>
                    <input type="number" id="score1" value="0" min="0">
                    <button onclick="changeScore('score1', 1)">+</button>
                </div>
                <span class="modal-vs">:</span>
                <div class="player-score-controls">
                    <button onclick="changeScore('score2', -1)">-</button>
                    <input type="number" id="score2" value="0" min="0">
                    <button onclick="changeScore('score2', 1)">+</button>
                </div>
            </div>

            <div class="knockout-winner-selection" id="knockoutWinnerSelection" style="display: none;">
                <div class="winner-option" id="winnerOption1" onclick="selectWinner(this)"></div>
                <div class="winner-option" id="winnerOption2" onclick="selectWinner(this)"></div>
                <div class="winner-option" id="winnerOptionNone" onclick="selectWinner(this, true)">Kein Gewinner (Match zurücksetzen)</div>
            </div>

            <button class="save-button" onclick="saveResultFromModal()">Ergebnis speichern</button>
        </div>
    </div>

    <script>
        // --- JavaScript Logik ---

        // Globale Variable zur Speicherung aller Spieler
        let allPlayers = [];
        const groupLetters = ['A', 'B', 'C', 'D'];
        let currentResultCell = null; // Speichert die Zelle, die das Modal geöffnet hat
        let isKnockoutModal = false; // Flag, um zu unterscheiden, ob K.O.-Modal offen ist
        let selectedKnockoutWinner = ''; // Speichert den im Modal ausgewählten Gewinner

        // Speichert die Match-Ergebnisse der Gruppenphase separat
        // Format: { groupA: [{player1: 'Name1', player2: 'Name2', result: '3:1'}, ...], ... }
        let groupMatchResults = {};

        // Speichert alle K.O.-Match-IDs und ihre zugehörigen Spieler-Felder
        const knockoutMatches = {
            'vf1': { player1: 'vf1_player1', player2: 'vf1_player2', nextPlayer: 'hf1_player1' },
            'vf2': { player1: 'vf2_player1', player2: 'vf2_player2', nextPlayer: 'hf1_player2' },
            'vf3': { player1: 'vf3_player1', player2: 'vf3_player2', nextPlayer: 'hf2_player1' },
            'vf4': { player1: 'vf4_player1', player2: 'vf4_player2', nextPlayer: 'hf2_player2' },
            'hf1': { player1: 'hf1_player1', player2: 'hf1_player2', nextPlayer: 'final_player1' },
            'hf2': { player1: 'hf2_player1', player2: 'hf2_player2', nextPlayer: 'final_player2' },
            'final': { player1: 'final_player1', player2: 'final_player2', nextPlayer: 'tournament_champion' }
        };

        /**
         * Schaltet die Sichtbarkeit einer Sektion um (ein-/ausklappen).
         * @param {string} sectionId - Die ID des zu schaltenden Elements.
         */
        function toggleSection(sectionId) {
            const sectionHeader = document.querySelector(`[onclick="toggleSection('${sectionId}')"]`);
            const sectionContent = document.getElementById(sectionId);
            
            if (!sectionHeader || !sectionContent) {
                console.error(`Section with ID ${sectionId} or its header not found.`);
                return;
            }

            const isCollapsed = sectionHeader.classList.contains('collapsed');
            
            if (isCollapsed) {
                sectionHeader.classList.remove('collapsed');
                sectionHeader.classList.add('expanded');
                sectionContent.style.display = 'block'; 
                // Set max-height to scrollHeight to allow smooth transition
                sectionContent.style.maxHeight = sectionContent.scrollHeight + "px"; 
            } else {
                sectionHeader.classList.remove('expanded');
                sectionHeader.classList.add('collapsed');
                sectionContent.style.maxHeight = "0"; // Trigger transition to collapse
                // After transition, set display to none to prevent interaction
                sectionContent.addEventListener('transitionend', function handler() {
                    if (sectionContent.classList.contains('collapsed') || !sectionHeader.classList.contains('expanded')) {
                        sectionContent.style.display = 'none';
                    }
                    sectionContent.removeEventListener('transitionend', handler);
                });
            }
        }

        // Funktion zum Parsen eines Ergebnis-Strings (z.B. "3:1")
        function parseResult(resultString) {
            if (!resultString || typeof resultString !== 'string' || !resultString.includes(':')) {
                return { won: 0, lost: 0, isValid: false };
            }
            const parts = resultString.split(':').map(Number);
            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                return { won: parts[0], lost: parts[1], isValid: true };
            }
            return { won: 0, lost: 0, isValid: false };
        }

        /**
         * Generiert einen optimierten Spielplan für eine Gruppe (Round Robin).
         * Priorisiert, dass Spieler nicht direkt aufeinanderfolgende Matches haben.
         * Dies ist eine Heuristik für 4 Spieler (6 Matches).
         * @param {Array<Object>} players - Die 4 Spielerobjekte einer Gruppe.
         * @returns {Array<Object>} Eine geordnete Liste von Match-Objekten.
         */
        function getOptimizedGroupSchedule(players) {
            const p = players.map(player => player.name); // Nur Namen für die Paarungen

            // Für 4 Spieler (P1, P2, P3, P4), eine mögliche Reihenfolge,
            // um aufeinanderfolgende Spiele desselben Spielers zu vermeiden.
            // Dies ist ein Standard-Round-Robin-Zeitplan ("Circle Method").
            const schedule = [
                { player1: p[0], player2: p[3] }, // P1 vs P4
                { player1: p[1], player2: p[2] }, // P2 vs P3
                { player1: p[3], player2: p[1] }, // P4 vs P2
                { player1: p[0], player2: p[2] }, // P1 vs P3
                { player1: p[2], player2: p[3] }, // P3 vs P4
                { player1: p[0], player2: p[1] }  // P1 vs P2
            ];
            return schedule;
        }

        /**
         * Richtet Spieler ein und weist sie Gruppen zu.
         * Wird beim Klicken auf "Spieler einrichten" aufgerufen.
         */
        function setupPlayersAndGroups() {
            const playerNamesInput = document.getElementById('playerNamesInput').value;
            const names = playerNamesInput.split('\n').map(name => name.trim()).filter(name => name !== '');

            if (names.length !== 16) {
                alert('Bitte gib genau 16 Spielernamen ein, jeden in einer neuen Zeile.');
                return;
            }

            allPlayers = [];
            const assignedPlayerListBody = document.getElementById('assignedPlayerList').querySelector('tbody');
            assignedPlayerListBody.innerHTML = ''; // Liste leeren

            // Spieler den Gruppen zuweisen
            for (let i = 0; i < names.length; i++) {
                const player = {
                    id: i + 1,
                    name: names[i],
                    group: groupLetters[Math.floor(i / 4)] // A, B, C, D
                };
                allPlayers.push(player);

                // Spieler zur zugewiesenen Spielerliste hinzufügen
                const row = assignedPlayerListBody.insertRow();
                row.innerHTML = `<td>${player.id}</td><td>${player.name}</td><td>${player.group}</td>`;
            }

            // Gruppentabellen und Matchlisten füllen
            groupLetters.forEach(groupLetter => {
                const groupPlayers = allPlayers.filter(p => p.group === groupLetter);
                if (groupPlayers.length === 4) {
                    // Speichere die generierten Matches in groupMatchResults
                    groupMatchResults[groupLetter] = getOptimizedGroupSchedule(groupPlayers).map(match => ({
                        player1: match.player1,
                        player2: match.player2,
                        result: '' // Initial kein Ergebnis
                    }));

                    renderGroupMatches(groupLetter); // Matches in die Anzeige rendern

                    // Ranking-Tabelle leeren und Initialisieren
                    const rankingTableBody = document.getElementById(`group${groupLetter}_ranking`).querySelector('tbody');
                    rankingTableBody.innerHTML = ''; // Leere alte Einträge
                    groupPlayers.forEach(player => {
                        const row = rankingTableBody.insertRow();
                        row.setAttribute('data-player-name', player.name);
                        row.innerHTML = `
                            <td>${player.name}</td>
                            <td class="games-played">0</td>
                            <td class="wins">0</td>
                            <td class="losses">0</td>
                            <td class="frames-plus">0</td>
                            <td class="frames-minus">0</td>
                            <td class="frames-diff">0</td>
                            <td class="points">0</td>
                            <td class="rank"></td>
                        `;
                    });
                    updateGroupResults(groupLetter); // Initialberechnung
                }
            });

            // Initialisiere K.O.-Felder mit Event-Listenern
            Object.keys(knockoutMatches).forEach(matchId => {
                const winnerCell = document.querySelector(`.winner.result-cell[data-match-id="${matchId}"]`);
                if (winnerCell) {
                    winnerCell.textContent = ''; // Leere alte Gewinner
                    winnerCell.classList.remove('played'); // Sicherstellen, dass Klasse entfernt ist
                    winnerCell.onclick = () => openResultModal(winnerCell, true); // true für K.O.-Phase
                }
            });
            document.getElementById('tournament_champion').textContent = ''; // Finalen Sieger leeren

            updateOverallNextGamesDisplay(); // Erste Anzeige der Gesamtübersicht der nächsten Spiele
            console.log('Spieler eingerichtet und Gruppen zugewiesen.');
        }

        /**
         * Rendert die Matches für eine spezifische Gruppe in der Liste.
         * Markiert auch das nächste anstehende Spiel pro Gruppe und aktualisiert den Billardtisch.
         * @param {string} groupId - Die ID der Gruppe (z.B. 'A').
         */
        function renderGroupMatches(groupId) {
            const matchesListDiv = document.getElementById(`group${groupId}_matches_list`);
            // Lösche alle alten Match-Items außer dem H3-Header
            Array.from(matchesListDiv.children).forEach(child => {
                if (child.tagName !== 'H3') {
                    child.remove();
                }
            });

            const matches = groupMatchResults[groupId];
            let foundNextMatch = false; // Flag, um das erste ungespielte Match zu finden
            let nextPlayer1 = '';
            let nextPlayer2 = '';

            matches.forEach((match, index) => {
                const matchItem = document.createElement('div');
                matchItem.classList.add('group-match-item');
                if (match.result !== '') {
                    matchItem.classList.add('played');
                } else if (!foundNextMatch) {
                    // Markiere das erste ungespielte Match als "next-up"
                    matchItem.classList.add('next-up');
                    foundNextMatch = true;
                    nextPlayer1 = match.player1;
                    nextPlayer2 = match.player2;
                }

                matchItem.innerHTML = `
                    <span class="players">${match.player1} vs. ${match.player2}</span>
                    <span class="result-display" data-group="${groupId}" data-match-index="${index}">${match.result}</span>
                `;
                // Füge Event Listener direkt zum result-display Span hinzu
                matchItem.querySelector('.result-display').onclick = (event) => {
                    const targetCell = event.currentTarget;
                    openResultModal(targetCell, false);
                };
                matchesListDiv.appendChild(matchItem);
            });

            // Aktualisiere den virtuellen Billardtisch für diese Gruppe
            document.getElementById(`group${groupId}_player1_on_table`).textContent = nextPlayer1;
            document.getElementById(`group${groupId}_player2_on_table`).textContent = nextPlayer2;

            if (!foundNextMatch) {
                // Wenn alle Matches gespielt sind, den Tisch leeren
                document.getElementById(`group${groupId}_player1_on_table`).textContent = '';
                document.getElementById(`group${groupId}_player2_on_table`).textContent = '';
            }
        }


        /**
         * Öffnet das Modal zur Ergebniseingabe.
         * @param {HTMLElement} cell - Die angeklickte Ergebnis-Zelle oder das Ergebnis-Display-Span.
         * @param {boolean} isKo - True, wenn es sich um ein K.O.-Match handelt, sonst false.
         */
        function openResultModal(cell, isKoMatch) {
            currentResultCell = cell; // Die aktuelle Zelle speichern
            isKnockoutModal = isKoMatch;
            selectedKnockoutWinner = ''; // Zurücksetzen der Auswahl

            const groupPhaseScoreInput = document.getElementById('groupPhaseScoreInput');
            const knockoutWinnerSelection = document.getElementById('knockoutWinnerSelection');
            const score1Input = document.getElementById('score1');
            const score2Input = document.getElementById('score2');

            let player1Name, player2Name;

            if (isKoMatch) {
                const matchId = cell.dataset.matchId;
                const matchInfo = knockoutMatches[matchId];
                player1Name = document.getElementById(matchInfo.player1).textContent.trim();
                player2Name = document.getElementById(matchInfo.player2).textContent.trim();

                // Wenn Spieler nicht gesetzt sind, Modal nicht öffnen
                if (!player1Name || !player2Name) {
                    alert('Bitte trage zuerst die Spieler in dieses K.O.-Match ein.');
                    currentResultCell = null; // Zurücksetzen, da Modal nicht geöffnet wird
                    return;
                }
                
                groupPhaseScoreInput.style.display = 'none'; // Gruppenphase-Eingabe verstecken
                knockoutWinnerSelection.style.display = 'flex'; // K.O.-Phase-Auswahl anzeigen

                // Setze die Namen für die klickbaren Optionen
                document.getElementById('winnerOption1').textContent = player1Name;
                document.getElementById('winnerOption2').textContent = player2Name;
                document.getElementById('winnerOption1').setAttribute('data-winner-name', player1Name);
                document.getElementById('winnerOption2').setAttribute('data-winner-name', player2Name);

                // Markiere den aktuell eingetragenen Gewinner, falls vorhanden
                const currentWinner = cell.textContent.trim();
                document.querySelectorAll('.knockout-winner-selection .winner-option').forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.winnerName === currentWinner) {
                        option.classList.add('selected');
                        selectedKnockoutWinner = currentWinner;
                    }
                });

            } else { // Gruppenphase
                const groupId = cell.dataset.group;
                const matchIndex = parseInt(cell.dataset.matchIndex);
                const match = groupMatchResults[groupId][matchIndex];
                player1Name = match.player1;
                player2Name = match.player2;

                groupPhaseScoreInput.style.display = 'flex'; // Gruppenphase-Eingabe anzeigen
                knockoutWinnerSelection.style.display = 'none'; // K.O.-Phase-Auswahl verstecken

                // Vorhandenes Ergebnis vorab ausfüllen (für Gruppenphase)
                const existingResult = parseResult(match.result);
                score1Input.value = existingResult.won;
                score2Input.value = existingResult.lost;
                score1Input.focus();
            }
            
            document.getElementById('modalPlayer1').textContent = player1Name;
            document.getElementById('modalPlayer2').textContent = player2Name;
            
            document.getElementById('resultModal').style.display = 'flex'; // Modal anzeigen
        }

        /**
         * Wählt den Gewinner im K.O.-Modal aus.
         * @param {HTMLElement} element - Das angeklickte Winner-Option-Element.
         * @param {boolean} isNoneOption - True, wenn die "Kein Gewinner" Option geklickt wurde.
         */
        function selectWinner(element, isNoneOption = false) {
            // Alle Optionen deselektieren
            document.querySelectorAll('.knockout-winner-selection .winner-option').forEach(option => {
                option.classList.remove('selected');
            });

            if (isNoneOption) {
                selectedKnockoutWinner = ''; // Setze Gewinner auf leer
            } else {
                element.classList.add('selected'); // Aktuelle Option auswählen
                selectedKnockoutWinner = element.dataset.winnerName;
            }
        }

        /**
         * Erhöht oder verringert den Score eines Spielers im Modal (Gruppenphase).
         * @param {string} scoreInputId - Die ID des Score-Input-Feldes ('score1' oder 'score2').
         * @param {number} delta - Wert, um den der Score geändert werden soll (+1 oder -1).
         */
        function changeScore(scoreInputId, delta) {
            const scoreInput = document.getElementById(scoreInputId);
            let currentValue = parseInt(scoreInput.value);
            currentValue = isNaN(currentValue) ? 0 : currentValue; // Sicherstellen, dass es eine Zahl ist
            let newValue = currentValue + delta;

            if (newValue < 0) {
                newValue = 0; // Score nicht unter 0 fallen lassen
            }
            scoreInput.value = newValue;
        }

        /**
         * Schließt das Modal zur Ergebniseingabe.
         */
        function closeModal() {
            document.getElementById('resultModal').style.display = 'none';
            currentResultCell = null;
            isKnockoutModal = false; // Flag zurücksetzen
            selectedKnockoutWinner = ''; // Auswahl zurücksetzen
            // Optional: reset input values for next open
            document.getElementById('score1').value = 0;
            document.getElementById('score2').value = 0;
        }

        /**
         * Speichert das Ergebnis aus dem Modal in der Zelle und aktualisiert die Tabelle.
         */
        function saveResultFromModal() {
            if (!currentResultCell) return;

            const player1Name = document.getElementById('modalPlayer1').textContent;
            const player2Name = document.getElementById('modalPlayer2').textContent;

            if (isKnockoutModal) {
                // K.O.-Phase: Gewinner wurde per Klick ausgewählt
                const resultValue = selectedKnockoutWinner;

                if (resultValue === player1Name || resultValue === player2Name) {
                    currentResultCell.textContent = resultValue;
                    currentResultCell.classList.add('played'); // Markierung für gespieltes KO-Match
                    updateKnockoutWinner(currentResultCell.dataset.matchId); // Gewinner in nächste Runde schieben
                    closeModal();
                } else if (resultValue === '') { // "Kein Gewinner" ausgewählt
                    currentResultCell.textContent = '';
                    currentResultCell.classList.remove('played');
                    clearNextRoundPlayer(currentResultCell.dataset.matchId); // Gewinner aus nächster Runde entfernen
                    closeModal();
                } else {
                    alert('Bitte wähle den Gewinner aus.'); // Sollte nicht passieren, wenn die Auswahl erzwungen wird
                    return;
                }
            } else {
                // Gruppenphase: Hier werden die Scores von den Zahlenfeldern genommen
                const score1 = parseInt(document.getElementById('score1').value);
                const score2 = parseInt(document.getElementById('score2').value);

                if (isNaN(score1) || isNaN(score2)) {
                    alert('Bitte gib gültige Zahlen für die Frames ein.');
                    return;
                }
                
                const resultString = `${score1}:${score2}`;
                
                const groupId = currentResultCell.dataset.group;
                const matchIndex = parseInt(currentResultCell.dataset.matchIndex);

                groupMatchResults[groupId][matchIndex].result = resultString;
                
                renderGroupMatches(groupId); // Die Liste neu rendern, um Klassen zu aktualisieren (inkl. next-up)
                updateGroupResults(groupId); // Rangliste aktualisieren
                closeModal();
            }
        }


        /**
         * Aktualisiert die Rangliste für eine bestimmte Gruppe basierend auf den Ergebnissen.
         * @param {string} groupId - Die ID der Gruppe (z.B. 'A', 'B', 'C', 'D').
         */
        function updateGroupResults(groupId) {
            console.log(`Updating results for Group ${groupId}`);
            const rankingTableBody = document.getElementById(`group${groupId}_ranking`).querySelector('tbody');
            
            // Alle Spieler dieser Gruppe holen
            const groupPlayers = allPlayers.filter(p => p.group === groupId);
            const playerNamesInGroup = groupPlayers.map(p => p.name);

            // Initialisiere Spielerdaten für diese Gruppe
            let playerData = playerNamesInGroup.map(name => ({
                name: name,
                gamesPlayed: 0,
                wins: 0,
                losses: 0,
                framesPlus: 0,
                framesMinus: 0,
                framesDiff: 0,
                points: 0
            }));

            // Ergebnisse auslesen und verarbeiten aus `groupMatchResults`
            const matches = groupMatchResults[groupId];
            matches.forEach(match => {
                const result = parseResult(match.result);

                if (result.isValid) {
                    const player1Index = playerData.findIndex(p => p.name === match.player1);
                    const player2Index = playerData.findIndex(p => p.name === match.player2);

                    if (player1Index !== -1 && player2Index !== -1) {
                        playerData[player1Index].gamesPlayed++;
                        playerData[player2Index].gamesPlayed++;

                        playerData[player1Index].framesPlus += result.won;
                        playerData[player1Index].framesMinus += result.lost;
                        playerData[player2Index].framesPlus += result.lost;
                        playerData[player2Index].framesMinus += result.won;

                        if (result.won > result.lost) {
                            playerData[player1Index].wins++;
                            playerData[player1Index].points += 2;
                            playerData[player2Index].losses++;
                        } else if (result.won < result.lost) {
                            playerData[player1Index].losses++;
                            playerData[player2Index].wins++;
                            playerData[player2Index].points += 2;
                        }
                    }
                }
            });

            // Frame-Differenz berechnen (gamesPlayed muss hier nicht durch 2 geteilt werden, da jedes Match nur einmal in `groupMatchResults` existiert)
            playerData.forEach(player => {
                player.framesDiff = player.framesPlus - player.framesMinus;
            });

            // Spieler nach Punkten, dann Frame-Differenz, dann Frames+ sortieren
            playerData.sort((a, b) => {
                if (b.points !== a.points) {
                    return b.points - a.points;
                }
                if (b.framesDiff !== a.framesDiff) {
                    return b.framesDiff - a.framesDiff;
                }
                return b.framesPlus - a.framesPlus;
            });

            // Rangliste im HTML aktualisieren
            rankingTableBody.innerHTML = ''; // Leere alte Einträge
            playerData.forEach((player, index) => {
                const row = rankingTableBody.insertRow();
                row.setAttribute('data-player-name', player.name);
                row.innerHTML = `
                    <td class="rank"><strong>${index + 1}</strong></td>
                    <td>${player.name}</td>
                    <td class="games-played">${player.gamesPlayed}</td>
                    <td class="wins">${player.wins}</td>
                    <td class="losses">${player.losses}</td>
                    <td class="frames-plus">${player.framesPlus}</td>
                    <td class="frames-minus">${player.framesMinus}</td>
                    <td class="frames-diff">${player.framesDiff}</td>
                    <td class="points">${player.points}</td>
                `;
            });
            updateOverallNextGamesDisplay(); // Gesamtübersicht der nächsten Spiele nach jeder Ergebniseingabe aktualisieren
        }


        /**
         * Zeigt alle ungespielten Matches (Gruppen- und K.O.-Phase) in der Gesamtübersicht an.
         */
        function updateOverallNextGamesDisplay() {
            const nextGamesSection = document.getElementById('nextGamesSection');
            nextGamesSection.innerHTML = '<h3>Ungespielte Matches (Gesamtübersicht):</h3>';
            let hasUpcomingGames = false;

            // Zuerst Gruppenphasen-Matches durchgehen
            groupLetters.forEach(groupLetter => {
                const matches = groupMatchResults[groupLetter];
                if (matches) {
                    matches.forEach(match => {
                        if (match.result.trim() === '') { // Wenn das Ergebnis leer ist
                            const gameItem = document.createElement('div');
                            gameItem.classList.add('next-game-item');
                            gameItem.innerHTML = `Gruppe ${groupLetter}: <span class="next-game-player">${match.player1}</span> vs. <span class="next-game-player">${match.player2}</span>`;
                            nextGamesSection.appendChild(gameItem);
                            hasUpcomingGames = true;
                        }
                    });
                }
            });

            // Dann K.O.-Matches prüfen
            for (const matchId in knockoutMatches) {
                const matchInfo = knockoutMatches[matchId];
                const player1Element = document.getElementById(matchInfo.player1);
                const player2Element = document.getElementById(matchInfo.player2);
                const winnerCell = document.querySelector(`.winner.result-cell[data-match-id="${matchId}"]`);

                // Prüfen, ob Spieler da sind und ob ein Gewinner eingetragen ist
                if (player1Element && player2Element && player1Element.textContent.trim() !== '' && player2Element.textContent.trim() !== '' && winnerCell.textContent.trim() === '') {
                    const player1Name = player1Element.textContent.trim();
                    const player2Name = player2Element.textContent.trim();

                    const gameItem = document.createElement('div');
                    gameItem.classList.add('next-game-item');
                    const matchRound = matchId.startsWith('vf') ? 'Viertelfinale' : (matchId.startsWith('hf') ? 'Halbfinale' : 'Finale');
                    gameItem.innerHTML = `${matchRound}: <span class="next-game-player">${player1Name}</span> vs. <span class="next-game-player">${player2Name}</span>`;
                    nextGamesSection.appendChild(gameItem);
                    hasUpcomingGames = true;
                }
            }


            if (!hasUpcomingGames) {
                const p = document.createElement('p');
                p.textContent = 'Alle Matches abgeschlossen!';
                nextGamesSection.innerHTML = ''; // Leere vorherigen Inhalt
                nextGamesSection.appendChild(p);
            }
        }


        /**
         * Überträgt den Gewinner eines K.O.-Matches in die nächste Runde.
         * @param {string} matchId - Die ID des Matches (z.B. 'vf1', 'hf1', 'final').
         */
        function updateKnockoutWinner(matchId) {
            const winnerElement = document.querySelector(`.winner.result-cell[data-match-id="${matchId}"]`);
            const winnerName = winnerElement.textContent.trim();
            const matchInfo = knockoutMatches[matchId];

            if (!matchInfo || !matchInfo.nextPlayer) {
                console.warn(`Keine Informationen für das nächste Spiel für MatchId: ${matchId}`);
                return;
            }
            
            const nextPlayerElement = document.getElementById(matchInfo.nextPlayer);

            if (nextPlayerElement) {
                nextPlayerElement.textContent = winnerName;
                console.log(`Winner "${winnerName}" from ${matchId} advanced to ${matchInfo.nextPlayer}.`);
            } else {
                console.warn(`Ziel-Element ${matchInfo.nextPlayer} nicht gefunden.`);
            }
            updateOverallNextGamesDisplay(); // Nächste Spiele aktualisieren
        }

        /**
         * Löscht Spieler aus der nächsten K.O.-Runde, wenn der Gewinner entfernt wurde.
         * @param {string} matchId - Die ID des Matches.
         */
        function clearNextRoundPlayer(matchId) {
            const matchInfo = knockoutMatches[matchId];
            if (matchInfo && matchInfo.nextPlayer) {
                const nextPlayerElement = document.getElementById(matchInfo.nextPlayer);
                if (nextPlayerElement) {
                    nextPlayerElement.textContent = '';
                }
            }
            // Rekursiv weitere abhängige Felder leeren (z.B. HF löschen leert auch Finale)
            for (const key in knockoutMatches) {
                // Prüfen, ob das "player1" oder "player2" Feld des nächsten Matches dem geleerten Feld entspricht
                if ((matchInfo.nextPlayer && knockoutMatches[key].player1 === matchInfo.nextPlayer) || 
                    (matchInfo.nextPlayer && knockoutMatches[key].player2 === matchInfo.nextPlayer)) {
                    
                    const dependentWinnerCell = document.querySelector(`.winner.result-cell[data-match-id="${key}"]`);
                    if (dependentWinnerCell) {
                        dependentWinnerCell.textContent = '';
                        dependentWinnerCell.classList.remove('played');
                        clearNextRoundPlayer(key); // Rekursiver Aufruf
                    }
                }
            }
            updateOverallNextGamesDisplay(); // Nächste Spiele aktualisieren
        }


        /**
         * (Manuell aufrufen per Button) Überträgt die Top 2 Spieler jeder Gruppe in die Viertelfinalfelder.
         * Diese Funktion sollte aufgerufen werden, NACHDEM alle Gruppenphasen abgeschlossen sind.
         */
        function qualifyGroupWinners() {
            const qualifiedPlayers = {};

            groupLetters.forEach(groupId => {
                const rankingTableBody = document.getElementById(`group${groupId}_ranking`).querySelector('tbody');
                const rows = Array.from(rankingTableBody.querySelectorAll('tr'));
                
                if (rows.length >= 2) {
                    qualifiedPlayers[groupId] = [
                        rows[0].querySelector('td:first-child').nextElementSibling.textContent.trim(), // Name des Erstplatzierten (2. td, da 1. jetzt Rang ist)
                        rows[1].querySelector('td:first-child').nextElementSibling.textContent.trim()  // Name des Zweitplatzierten (2. td, da 1. jetzt Rang ist)
                    ];
                } else {
                    console.warn(`Nicht genug Spieler in Gruppe ${groupId}, um 2 zu qualifizieren.`);
                    qualifiedPlayers[groupId] = [];
                }
            });

            // Trage die qualifizierten Spieler in die Viertelfinalfelder ein
            if (qualifiedPlayers.A && qualifiedPlayers.B && qualifiedPlayers.C && qualifiedPlayers.D &&
                qualifiedPlayers.A.length === 2 && qualifiedPlayers.B.length === 2 && 
                qualifiedPlayers.C.length === 2 && qualifiedPlayers.D.length === 2) {

                document.getElementById('vf1_player1').textContent = qualifiedPlayers.A[0] || ''; // Erster Gruppe A
                document.getElementById('vf1_player2').textContent = qualifiedPlayers.B[1] || ''; // Zweiter Gruppe B

                document.getElementById('vf2_player1').textContent = qualifiedPlayers.C[0] || ''; // Erster Gruppe C
                document.getElementById('vf2_player2').textContent = qualifiedPlayers.D[1] || ''; // Zweiter Gruppe D

                document.getElementById('vf3_player1').textContent = qualifiedPlayers.B[0] || ''; // Erster Gruppe B
                document.getElementById('vf3_player2').textContent = qualifiedPlayers.A[1] || ''; // Zweiter Gruppe A

                document.getElementById('vf4_player1').textContent = qualifiedPlayers.D[0] || ''; // Erster Gruppe D
                document.getElementById('vf4_player2').textContent = qualifiedPlayers.C[1] || ''; // Zweiter Gruppe C
                
                console.log("Qualifizierte Spieler wurden in das K.O.-Bracket übertragen.");
            } else {
                alert("Konnte nicht alle Spieler qualifizieren. Stelle sicher, dass alle Gruppenspiele eingegeben sind und jede Gruppe mindestens 2 qualifizierte Spieler hat.");
                console.error("Qualifizierung fehlgeschlagen: Nicht alle Gruppen hatten Top-2-Spieler.");
            }
            updateOverallNextGamesDisplay(); // Nächste Spiele aktualisieren
        }


        // Service Worker Registrierung
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registriert mit Scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.error('ServiceWorker Registrierung fehlgeschlagen: ', error);
                    });
            });
        }

        // Initialer Aufruf beim Laden der Seite
        document.addEventListener('DOMContentLoaded', () => {
            // Event-Listener für das Modal, um es bei Klick außerhalb des Inhalts zu schließen
            const modal = document.getElementById('resultModal');
            modal.addEventListener('click', (event) => {
                if (event.target === modal) {
                    closeModal();
                }
            });

            // Initialisiere die einklappbaren Sektionen als geschlossen
            const sectionsToCollapse = ['instructionsSection', 'playerSetupSection', 'nextGamesSectionWrapper'];
            sectionsToCollapse.forEach(id => {
                const header = document.querySelector(`[onclick="toggleSection('${id}')"]`);
                if (header) {
                    header.classList.add('collapsed');
                    // Setze max-height auf 0 direkt beim Laden, damit der Transition-Effekt funktioniert
                    document.getElementById(id).style.maxHeight = '0';
                    document.getElementById(id).style.display = 'none'; // Verstecke den Inhalt beim Laden
                }
            });

            updateOverallNextGamesDisplay(); // Erste Anzeige der Gesamtübersicht der nächsten Spiele
        });
    </script>
</body>
</html>
