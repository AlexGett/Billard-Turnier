<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="mainTitle">Billard Turnierplan - PWA</title>
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Billard Turnier">
    <meta name="theme-color" content="#f4f4f4">

    <style>
        body {
            font-family: Arial, sans-serif;
    	    margin: 20px;
    	    background-color: #FFFFFF;
    	    color: #000000;
    	    background-image: url(Logo.png);
   	    background-repeat: no-repeat;
    	    background-position: 860px 15px;
     	    background-attachment: fixed;
   	    background-size: 350px;
    	    z-index: -1;
        }

        /* Setze die Opazität für alle anderen Elemente wieder auf 1, da der Body die Opazität setzt */
        body > * {
            opacity: 1;
            z-index: 1; /* Stelle sicher, dass der Inhalt über dem Hintergrund liegt */
            position: relative; /* Erforderlich für z-index, um auf Nicht-Statische Elemente zu wirken */
        }


        h1 { color: #000000;
    	background-color: #ffffff;
    	border-radius: 5px;
    	border: 2px solid #000000;
    	width: 660px;
    	height: 42px;
    	padding: 0px 15px;
    	box-shadow: 0px 0px 20px 0px rgb(218 19 26); }
	h2, h3 { color: #000000; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; background-color: #fff; box-shadow: 0 2px 3px rgba(0,0,0,0.1); }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #e2e2e2; }
        .group-table td:first-child, .group-table th:first-child { text-align: left; }
        .player-list td:first-child { text-align: left; }

        /* NEU: Flexbox für den Hauptcontainer der Gruppen */
        .all-groups-container {
            display: flex;
            flex-wrap: wrap; /* Erlaubt Umbruch auf kleineren Bildschirmen */
            gap: 20px; /* Abstand zwischen den Gruppen */
            justify-content: center; /* Zentriert die Gruppen */
            align-items: flex-start; /* Füge hier align-items hinzu, um alle Gruppen oben auszurichten */
        }

        /* NEU: Stil für die direkt in .all-groups-container enthaltenen divs (die Wrapper für jede Gruppe) */
        .all-groups-container > div { /* Selektiert die direkten div-Kinder des all-groups-container */
            flex: 1 1 calc(50% - 10px); /* Nimmt 50% Breite minus halbem Gap */
            min-width: 450px; /* Mindestbreite, damit der Inhalt nicht zu stark schrumpft */
            max-width: calc(50% - 10px); /* Maximal 50% abzüglich Gap */
            box-sizing: border-box; /* Stellt sicher, dass Padding/Border in die Breite einfließen */
        }


        /* Flexbox für Gruppen-Sektionen */
        .group-section {
            display: flex;
            flex-wrap: wrap; /* Erlaubt Umbruch, wenn kein Platz */
            gap: 20px;
            margin-bottom: 0; /* Entferne den unteren Margin, da der Elterncontainer Gap hat */
            align-items: flex-start;
            /* Diese Flex-Eigenschaften sollten nur die Aufteilung INNERHALB einer Gruppe steuern */
            width: 100%; /* Sichert, dass die innere Sektion die volle Breite ihres Elternelements nutzt */
        }
        /* Sicherstellen, dass der H2-Titel einer Gruppe über der Gruppe selbst ist */
        .group-header {
            width: 100%; /* H2 nimmt volle Breite */
            margin-bottom: 10px; /* Abstand zum Gruppen-Container */
            margin-top: 20px; /* Abstand zum vorherigen Element */
        }
        .group-header h2 {
             margin-top: 0;
        }

        /* NEU: Container für Matchliste und Billardtisch */
        .group-primary-display {
            display: flex; /* Macht die Kinder (Matchliste, Billardtisch) zu Flex-Items */
            flex-wrap: wrap; /* Erlaubt Umbruch, falls kein Platz */
            gap: 20px; /* Abstand zwischen Matchliste und Billardtisch */
            flex: 2; /* Nimmt mehr Platz ein als group-details, wenn vorhanden */
            min-width: 600px; /* Mindestbreite für dieses Duo */
            align-items: flex-start; /* Oben ausrichten */
        }

        .group-details {
            flex: 1; /* Nimmt verfügbaren Platz ein, aber weniger als group-primary-display */
            min-width: 320px; /* Mindestbreite für Details (Tabelle) */
        }

        .group-matches-list {
            flex: 1; /* Nimmt verfügbaren Platz im group-primary-display ein */
            min-width: 280px; /* Mindestbreite für Matchliste */
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow:  0px 0px 20px rgba(0, 0, 0, 0.384);
        }
        .group-matches-list h3 {
            margin-top: 0;
            color: #000000;
        }
        .group-match-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed #eee;
            position: relative; /* Für die Markierung des nächsten Spiels */
        }
        .group-match-item:last-child {
            border-bottom: none;
        }
        .group-match-item .players {
            font-weight: bold;
            color: #333;
            flex-grow: 1; /* Lässt Spieler-Namen den meisten Platz einnehmen */
            text-align: left;
        }
        .group-match-item .result-display {
            font-style: italic;
            color: #555;
            min-width: 100px; /* Platz für Ergebnis */
            min-height: 12px;
            text-align: right;
            cursor: pointer; /* Damit der Bereich klickbar ist */
            padding: 2px 5px; /* Klickfläche vergrößern */
            border: 1px solid transparent; /* Rahmen für Klickbarkeit */
            border-radius: 3px;
        }
        .group-match-item .result-display:hover {
            background-color: #f0f0f0;
            border-color: #ffffff;
        }
        .group-match-item.played .players {
            text-decoration: line-through;
            color: #888;
        }
        .group-match-item.played .result-display {
            color: #888;
            background-color: #ffffff;
        }

        /* NEU: Stil für das nächste anstehende Spiel in der Gruppenliste */
        .group-match-item.next-up {
            background-color: #fffacd; /* Light yellow */
            border: 2px solid #ffd700; /* Gold border */
            padding: 8px 10px; /* etwas mehr padding */
            border-radius: 5px;
            margin: 5px 0;
        }

        /* NEU: Stil für den Billardtisch */
        .group-billiard-table {
            flex-shrink: 0; /* Verhindert, dass der Tisch schrumpft */
            width: 150px; /* Feste Breite */
            height: 290px; /* Feste Höhe */
            background-color: #008dde; /* Dunkelgrün für Billardtuch */
            border: 10px solid #3d4655; /* Brauner Rahmen für den Tisch */
            border-radius: 15px; /* Leicht abgerundete Ecken */
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column; /* Spieler untereinander */
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            padding: 10px;
            box-sizing: border-box; /* Padding in die Breite/Höhe einbeziehen */
        }

        .group-billiard-table .table-title {
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #aaddaa;
        }

        .group-billiard-table .player-on-table {
            font-size: 1.1em;
            margin: 3px 0;
            padding: 2px 5px;
            background-color: rgba(255,255,255,0.1); /* Leicht transparenter Hintergrund für Namen */
            border-radius: 3px;
        }
        .group-billiard-table .player-on-table:empty::before {
            content: "Wartet..."; /* Platzhalter, wenn kein Spieler da ist */
            color: rgba(255,255,255,0.5);
        }

        .knockout-bracket {
            display: flex;
            justify-content: center; /* Zentriert die Spalten */
            align-items: flex-start;
            flex-wrap: wrap; /* Erlaubt Umbruch */
            gap: 20px; /* Abstand zwischen den Spalten */
        }
        .round-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 250px; /* Mindestbreite für jede Runde */
            flex: 1; /* Gleichmäßige Verteilung des Platzes */
            max-width: 280px; /* Maximale Breite für jede Runde */
        }
        .match {
            border: 1px solid #ccc;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            background-color: #f9f9f9;
            width: 100%; /* Passt sich der Spaltenbreite an */
            max-width: 220px; /* Begrenzung der Match-Box Breite */
            text-align: center;
            box-sizing: border-box;
            position: relative;
	    box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.384);
        }
        .match-label { font-weight: bold; margin-bottom: 5px; color: #555; }
        .player-name { margin-bottom: 3px; min-height: 1.2em; font-weight: bold;}
        .vs { font-style: italic; color: #666; margin: 2px 0; }
        /* Stil für Ergebnis-Zellen in K.O.-Phase (Gewinner) */
        .winner.result-cell {
            width: auto; /* An Inhalt anpassen */
            height: auto;
            min-height: 1.2em; /* Wie player-name */
            font-weight: bold;
            color: green;
            margin-top: 5px;
            cursor: pointer;
            border: 1px solid #ccc; /* Rahmen wie bei Gruppenphase */
            display: flex; /* Für Zentrierung des Textes */
            align-items: center;
            justify-content: center;
            padding: 2px 5px; /* Etwas Padding */
        }
        .winner.result-cell:empty {
            background-color: #e0ffe0; /* Hellgrüner Hintergrund für leere Gewinner-Felder */
        }
        .winner.result-cell.played {
            text-decoration: none; /* Gewinner sollen nicht durchgestrichen werden */
            color: green;
            background-color: #d4edda; /* Etwas dunkler, wenn Ergebnis da ist */
        }
        .winner.result-cell:hover:not(.played) {
            background-color: #f0f8ff; /* Sehr hellblau bei Hover */
        }

        .final-winner { font-size: 1.5em; font-weight: bold; color: #d9534f; margin-top: 40px; text-align: center; width: 100%; }
        .instructions ol { list-style-type: decimal; padding-left: 20px; }
        .instructions li { margin-bottom: 5px; }

        .qualify-button, .setup-players-button {
            display: block;
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #0a6c45;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            text-decoration: none;
            max-width: 300px; /* Button nicht zu breit machen */
        }
        .qualify-button:hover, .setup-players-button:hover {
            background-color: #0a6c45;
	    color: gray;
        }

        /* NEU: Toggle-Funktionalität für Sektionen */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            width: 320px;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            margin-top: 15px;
            color: #FFFFFF;
            background-color: #2d4198; /* Leichter Hintergrund für Header */
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid #000000;
        }
        .collapsible-header h2 {
            margin: 0;
            color: #FFFFFF;
        }
        .toggle-icon {
            font-size: 1.5em;
            transition: transform 0.3s ease;
        }
        .collapsible-header.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        .collapsible-content {
            display: none;
            overflow: hidden;
            max-height: 0; /* Startwert für Transition */
            transition: max-height 0.5s ease-in-out; /* Weicherer Übergang */
            padding-bottom: 20px; /* Abstand nach Sektion, wenn geöffnet */
        }
        .collapsible-header.expanded + .collapsible-content {
            display: block; /* Wichtig: setzt display auf block, damit max-height wirkt */
            max-height: 1000px; /* Genug Platz für Inhalt, höher als erwarteter Inhalt */
        }

        .player-input-area textarea {
            width: 100%;
            max-width: 500px; /* Begrenzung für bessere Lesbarkeit */
            height: 150px; /* Etwas höher für 16 Namen */
            padding: 10px;
            font-size: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        /* Die 'Nächste Spiele' Sektion wird nun nur noch die Gesamtübersicht ungespielter Matches darstellen */
        /* Diese Sektion wird nun komplett entfernt */
        /*
        .next-games-section {
            background-color: #e6f7ff;
            border: 1px solid #91d5ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        .next-game-item {
            padding: 8px 0;
            border-bottom: 1px dashed #cceeff;
        }
        .next-game-item:last-child {
            border-bottom: none;
        }
        .next-game-player {
            font-weight: bold;
            color: #0056b3;
        }
        */

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6); /* Dunklerer Hintergrund */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px; /* Mehr Padding */
            border: 1px solid #888;
            width: 90%; /* Etwas breiter auf kleineren Screens */
            max-width: 450px; /* Maximale Breite */
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); /* Stärkerer Schatten */
            text-align: center;
            position: relative;
        }
        .modal-content h3 {
            margin-top: 0;
            color: #2d4198;
            margin-bottom: 20px;
        }
        
        /* Adjusted Styles for Score Input with Arrows */
        .score-input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 15px 0;
            gap: 10px; /* Reduced gap for a more compact look */
        }
        .score-input-group .player-score-controls {
            display: flex;
            align-items: center;
            gap: 5px; /* Smaller gap between button and input */
            border: 1px solid #dcdcdc; /* Subtle border around controls */
            border-radius: 5px;
            padding: 2px; /* Inner padding for the group */
            background-color: #f9f9f9; /* Light background */
        }
        .score-input-group button {
            background-color: #e0e0e0; /* Lighter grey for buttons */
            color: #333; /* Darker text for contrast */
            border: none;
            border-radius: 4px; /* Slightly smaller border radius */
            padding: 4px 8px; /* Smaller padding for a more discreet look */
            font-size: 1.1em; /* Slightly smaller font */
            cursor: pointer;
            flex-shrink: 0;
            transition: background-color 0.2s ease;
        }
        .score-input-group button:hover {
            background-color: #d0d0d0; /* Darker grey on hover */
        }
        .score-input-group input[type="number"] {
            width: 50px; /* More compact width */
            padding: 6px; /* Reduced padding */
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em; /* Standard font size */
            text-align: center;
            -moz-appearance: textfield;
            background-color: #fff;
        }
        /* Hide default arrows in Chrome/Safari/Edge */
        .score-input-group input[type=number]::-webkit-inner-spin-button,
        .score-input-group input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .modal-content .modal-vs {
            font-size: 1.1em; /* Slightly smaller font */
            font-weight: normal; /* Less bold */
            margin: 0 10px; /* Reduced margin */
            min-width: 20px; /* Smaller min-width */
            color: #666; /* More subtle color */
        }

        /* NEU: Styles for clickable winner names in KO modal */
        .knockout-winner-selection {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        .knockout-winner-selection .winner-option {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            background-color: #ffffff; /* Light blue background */
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .knockout-winner-selection .winner-option:hover {
            background-color: #fffacd; /* Darker blue on hover */
            border-color: #91d5ff;
        }
        .knockout-winner-selection .winner-option.selected {
            background-color: #28a745; /* Green for selected */
            color: white;
            border-color: #218838;
        }
        .knockout-winner-selection .winner-option.selected:hover {
            background-color: #218838;
        }


        .modal-content button.save-button { /* Spezifischer für den Speichern-Button */
            background-color: #28a745;
            color: white;
            padding: 12px 20px; /* Größerer Button */
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            margin-top: 25px; /* Mehr Abstand */
        }
        .modal-content button.save-button:hover {
            background-color: #218838;
        }
        .close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #aaa;
            font-size: 32px; /* Größer für leichtere Klickbarkeit */
            font-weight: bold;
            cursor: pointer;
        }
        .close-button:hover,
        .close-button:focus {
            color: #333;
            text-decoration: none;
        }

        /* --- LOGO STYLES (ENTFERNT, DA ES NUN HINTERGRUND IST) --- */
        /*
        .logo-container {
            position: absolute;
            top: 15px;
            left: 990px;
            z-index: 500;
        }
        .logo-container img {
            max-width: 335px;
            height: auto;
            border-radius: 8px;
            box-shadow: inset 0 2px 20px rgba(0, 0, 0, 0.2);
        }
        */

        /* --- TROPHY ANIMATION STYLES --- */
        #trophyAnimationContainer {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
            z-index: 2000; /* Above everything else */
            justify-content: center; /* ONLY APPLY FLEX PROPERTIES WHEN IT'S ACTIVE */
            align-items: center;
            flex-direction: column;
            text-align: center;
            color: gold;
            font-size: 3em;
            font-weight: bold;
            cursor: pointer; /* Make it clickable */
        }

        #trophyAnimationContainer.active {
            display: flex; /* Show when active */
        }

        #trophyAnimationContainer img {
            width: 300px; /* Size of the trophy */
	    border-radius: 50px;
            height: auto;
            margin-bottom: 20px;
            animation: bounceIn 1s ease-out forwards, glow 2s infinite alternate; /* Combined animations */
        }

        #trophyAnimationContainer .winner-text {
            animation: fadeIn 1.5s ease-in-out forwards;
            animation-delay: 0.5s; /* Delay text appearance */
            opacity: 0;
            margin-top: 10px;
        }

        @keyframes bounceIn {
            0% { transform: scale(0.1); opacity: 0; }
            60% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); }
        }

        @keyframes glow {
            0% { box-shadow: 0 0 10px 5px rgba(255, 215, 0, 0.4); } /* Gold glow */
            50% { box-shadow: 0 0 25px 15px rgba(255, 215, 0, 0.8); }
            100% { box-shadow: 0 0 10px 5px rgba(255, 215, 0, 0.4); }
        }

        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        /* Media Queries for Responsiveness */
        @media (max-width: 1300px) { /* Anpassen für 1 Spalte Layout */
            .all-groups-container > div {
                flex: 1 1 100%; /* Jede Gruppe nimmt volle Breite */
                max-width: 100%;
                min-width: unset; /* Mindestbreite zurücksetzen */
                margin-bottom: 20px; /* Abstand zwischen gestapelten Gruppen */
            }
            .all-groups-container > div:last-child {
                margin-bottom: 0; /* Kein Margin für die letzte Gruppe */
            }
            .group-section {
                flex-direction: column; /* Stapelt Gruppen-Details unter Matchliste */
                align-items: stretch; /* Volle Breite */
            }
            .group-primary-display { /* Auch diesen Container stapeln, wenn section gestapelt ist */
                flex-direction: column;
                min-width: unset; /* Mindestbreite zurücksetzen */
                width: 100%;
                flex: none;
            }
            .group-details, .group-matches-list, .group-billiard-table {
                min-width: unset; /* Setzt Mindestbreite zurück */
                width: 100%; /* Volle Breite */
                flex: none; /* Keine Flex-Schrumpfung/Wachstum */
            }
            .knockout-bracket {
                flex-direction: column; /* Stapelt K.O.-Runden untereinander */
                align-items: center;
            }
            .round-column {
                min-width: unset;
                width: 95%; /* Etwas Abstand am Rand */
                max-width: 350px; /* Begrenzt die Breite auf kleineren Geräten */
            }
            .match {
                max-width: 100%; /* Match-Box nimmt volle Breite der Spalte ein */
            }
            .modal-content {
                width: 95%;
                padding: 20px;
            }
            /* .logo-container { */ /* Entfernt */
            /* position: fixed; */
            /* text-align: center; */
            /* margin-bottom: 15px; */
            /* } */
            /* .logo-container img { */ /* Entfernt */
            /* max-width: 335px; */
            /* } */
        }
        @media (max-width: 480px) {
            body { margin: 10px; }
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.4em; }
            /* The score input group is already horizontal,
               but if it needs to stack on very small screens,
               this would be the place for it.
               Currently, it should remain horizontal due to reduced gaps. */
            /* .score-input-group {
                flex-direction: column;
                gap: 10px;
            } */
            .modal-content .modal-vs {
                margin: 5px 0; /* Reduced margin for very small screens */
            }
        }
    </style>
</head>
<body>
    <h1 id="mainHeading">Billard Turnierplan</h1>

    <div class="collapsible-header collapsed" onclick="toggleSection('instructionsSection')">
        <span class="toggle-icon">&#9660;</span><h2>Anleitung & Turnierinfos</h2>
    </div>
    <div id="instructionsSection" class="collapsible-content">
        <div class="instructions">
            <ol>
                <li>Wähle die Anzahl der Spieler und **die Anzahl der Tische** und klicke auf "Neues Turnier starten".</li>
                <li>Klicke auf "Spieler einrichten", um das Eingabefeld zu öffnen. Trage alle Spielernamen (jeder Name in einer neuen Zeile) ein. Klicke dann auf "Spieler einrichten & Gruppen zuweisen".</li>
                <li>In den Gruppen-Sektionen siehst du die Liste der Matches pro Gruppe. Das **nächste anstehende Spiel ist gelb hervorgehoben**. Klicke auf das Ergebnisfeld eines Matches, um das Ergebnis einzutragen (z.B. '3:1' oder mit den Pfeilen). Gespielte Matches werden durchgestrichen. Die Spieler des nächsten Matches erscheinen auf dem **virtuellen Billardtisch** neben der Matchliste.</li>
                <li>Wenn alle Gruppenspiele beendet sind, klicke den Button "Qualifizierte Spieler zur K.O.-Phase hinzufügen".</li>
                <li>Trage dann die Gewinner der K.O.-Matches ein, indem du auf das leere Gewinnerfeld klickst. **Wähle den Gewinner einfach per Klick im Modal aus.** Sie rücken automatisch in die nächste Runde vor.</li>
            </ol>
            <h3>Regeln:</h3>
            <ul>
                <li><strong>Punkte:</strong> 2 Punkte für Sieg, 0 Punkte für Niederlage</li>
                <li><strong>Tie-Breaker (bei Punktgleichheit):</strong> 1. Punkte, 2. Frame-Differenz, 3. Mehr gewonnene Frames. (Direkter Vergleich ist nicht automatisiert)</li>
            </ul>
        </div>
    </div>

    

    <div class="player-selection-area">
        <label for="playerCount">Anzahl der Spieler:</label>
        <select id="playerCount" onchange="updatePlayerInputPlaceholder()">
            <option value="8">8 Spieler</option>
            <option value="16" selected>16 Spieler</option>
            <option value="32">32 Spieler</option>
        </select>
        <br><br> <label for="tableCount">Anzahl der Tische (Gruppen):</label>
        <select id="tableCount" onchange="updatePlayerInputPlaceholder()">
            <option value="2">2 Tische</option>
            <option value="4" selected>4 Tische</option>
            <option value="8">8 Tische</option>
        </select>
        <button class="setup-players-button" onclick="startNewTournament()">Neues Turnier starten</button>
    </div>

    <div class="collapsible-header collapsed" onclick="toggleSection('playerSetupSection')">
        <span class="toggle-icon">&#9660;</span><h2>Spieler einrichten</h2>
    </div>
    <div id="playerSetupSection" class="collapsible-content">
        <div class="player-input-area">
            <label for="playerNamesInput" id="playerInputLabel">Trage 16 Spielernamen ein (jeden Namen in einer neuen Zeile):</label><br>
            <textarea id="playerNamesInput" rows="10" placeholder="Spieler 1&#10;Spieler 2&#10;...&#10;Spieler 16"></textarea>
            <button class="setup-players-button" onclick="setupPlayersAndGroups()" id="assignPlayersButton">Spieler einrichten & Gruppen zuweisen</button>
        </div>
        <h2>Zugewiesene Spieler & Gruppen</h2>
        <table id="assignedPlayerList" class="player-list">
            <thead>
                <tr>
                    <th>Spieler-ID</th>
                    <th>Name</th>
                    <th>Gruppe</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </div>

    <div class="all-groups-container" id="allGroupsContainer">
        </div>

    <h2 id="knockoutPhaseTitle">K.O.-Phase</h2>
    <button class="qualify-button" onclick="qualifyGroupWinners()" id="qualifyButton">Qualifizierte Spieler zur K.O.-Phase hinzufügen</button>
    <div class="knockout-bracket" id="knockoutBracket">
        <div class="final-winner">
            <h3>TURNIERSIEGER: <span id="tournament_champion"></span></h3>
        </div>
    </div>

    <div id="resultModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal()">&times;</span>
            <h3>Ergebnis eingeben</h3>
            <p><span id="modalPlayer1"></span> <span class="modal-vs">vs.</span> <span id="modalPlayer2"></span></p>
            
            <div class="score-input-group" id="groupPhaseScoreInput">
                <div class="player-score-controls">
                    <button onclick="changeScore('score1', -1)">-</button>
                    <input type="number" id="score1" value="0" min="0">
                    <button onclick="changeScore('score1', 1)">+</button>
                </div>
                <span class="modal-vs">:</span>
                <div class="player-score-controls">
                    <button onclick="changeScore('score2', -1)">-</button>
                    <input type="number" id="score2" value="0" min="0">
                    <button onclick="changeScore('score2', 1)">+</button>
                </div>
            </div>

            <div class="knockout-winner-selection" id="knockoutWinnerSelection" style="display: none;">
                <div class="winner-option" id="winnerOption1" onclick="selectWinner(this)"></div>
                <div class="winner-option" id="winnerOption2" onclick="selectWinner(this)"></div>
                <div class="winner-option" id="winnerOptionNone" onclick="selectWinner(this, true)">Kein Gewinner (Match zurücksetzen)</div>
            </div>

            <button class="save-button" onclick="saveResultFromModal()">Ergebnis speichern</button>
        </div>
    </div>

    <div id="trophyAnimationContainer">
        <img src="Trophy.png" alt="Trophy" id="trophyImage"> <div class="winner-text">HERZLICHEN GLÜCKWUNSCH!</div>
        <div class="winner-text" id="animatedWinnerName"></div>
    </div>


    <script>
        // --- JavaScript Logik ---

        // Globale Variablen
        let allPlayers = [];
        let groupLetters = []; // Wird nun dynamisch gesetzt
        let currentResultCell = null;
        let isKnockoutModal = false;
        let selectedKnockoutWinner = '';
        let groupMatchResults = {};
        let knockoutMatches = {}; // Wird dynamisch gesetzt

        let numberOfPlayers = 16; // Standardwert
        let numberOfTables = 4; // Standardwert für Tische (entspricht Gruppen)
        let tournamentInProgress = false; // Flag for active tournament

        // DOM Elemente
        const mainHeading = document.getElementById('mainHeading');
        const playerCountSelect = document.getElementById('playerCount');
        const tableCountSelect = document.getElementById('tableCount'); // NEU
        const playerNamesInput = document.getElementById('playerNamesInput');
        const playerInputLabel = document.getElementById('playerInputLabel');
        const assignPlayersButton = document.getElementById('assignPlayersButton');
        const qualifyButton = document.getElementById('qualifyButton');
        const allGroupsContainer = document.getElementById('allGroupsContainer');
        const knockoutBracketDiv = document.getElementById('knockoutBracket');
        const tournamentChampionSpan = document.getElementById('tournament_champion');
        const assignedPlayerListBody = document.getElementById('assignedPlayerList').querySelector('tbody');
        const trophyAnimationContainer = document.getElementById('trophyAnimationContainer');
        const animatedWinnerName = document.getElementById('animatedWinnerName');

        /**
         * Schaltet die Sichtbarkeit einer Sektion um (einklappen/ausklappen).
         * @param {string} sectionId - Die ID der Sektion, die umgeschaltet werden soll.
         */
        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId);
            const header = document.querySelector(`[onclick="toggleSection('${sectionId}')"]`);
            if (content && header) {
                if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                    content.style.display = 'block'; // Set display to block before setting max-height
                    content.style.maxHeight = content.scrollHeight + "px";
                    header.classList.remove('collapsed');
                    header.classList.add('expanded');
                } else {
                    content.style.maxHeight = '0px';
                    header.classList.remove('expanded');
                    header.classList.add('collapsed');
                    // Give a short delay before setting display to 'none' to allow transition to complete
                    setTimeout(() => {
                        if (content.style.maxHeight === '0px') { // Ensure it's still collapsed
                            if (content.style.display !== 'none') { // Only set to none if not already
                                content.style.display = 'none';
                            }
                        }
                    }, 500); // Adjust this delay to match your CSS transition duration
                }
            }
        }


        /**
         * Initialisiert die Seite beim Laden.
         */
        document.addEventListener('DOMContentLoaded', () => {
            // Event-Listener für das Modal, um es bei Klick außerhalb des Inhalts zu schließen
            const modal = document.getElementById('resultModal');
            modal.addEventListener('click', (event) => {
                if (event.target === modal) {
                    closeModal();
                }
            });

            // Initialisiere die einklappbaren Sektionen als geschlossen
            const sectionsToCollapse = ['instructionsSection', 'playerSetupSection']; // 'nextGamesSectionWrapper' entfernt
            sectionsToCollapse.forEach(id => {
                const header = document.querySelector(`[onclick="toggleSection('${id}')"]`);
                if (header) {
                    header.classList.add('collapsed');
                    document.getElementById(id).style.maxHeight = '0';
                    document.getElementById(id).style.display = 'none';
                }
            });

            // Event-Listener für die Trophäen-Animation zum Beenden
            trophyAnimationContainer.addEventListener('click', () => {
                if (trophyAnimationContainer.classList.contains('active')) {
                    if (confirm('Möchtest du die Animation beenden?')) {
                        trophyAnimationContainer.classList.remove('active');
                    }
                }
            });

            // Setze den initialen Player und Table Count und Update UI
            updatePlayerInputPlaceholder();
            updateMainTitle();
            resetTournamentUI(); // Stellt sicher, dass die UI beim Laden sauber ist
        });

        /**
         * Aktualisiert den Haupttitel basierend auf der ausgewählten Spieleranzahl.
         */
        function updateMainTitle() {
            mainHeading.textContent = `Billard Turnierplan (${numberOfPlayers} Spieler / ${numberOfTables} Tische)`;
        }

        /**
         * Aktualisiert den Placeholder und Label des Textfeldes für Spielernamen.
         */
        function updatePlayerInputPlaceholder() {
            numberOfPlayers = parseInt(playerCountSelect.value);
            numberOfTables = parseInt(tableCountSelect.value); // NEU: Tischanzahl lesen

            playerInputLabel.textContent = `Trage ${numberOfPlayers} Spielernamen ein (jeden Namen in einer neuen Zeile):`;
            let placeholderText = '';
            for (let i = 1; i <= numberOfPlayers; i++) {
                placeholderText += `Spieler ${i}\n`;
            }
            playerNamesInput.placeholder = placeholderText.trim();
            updateMainTitle(); // Titel anpassen
        }

        /**
         * Startet ein neues Turnier und setzt die UI zurück.
         */
        function startNewTournament() {
            if (tournamentInProgress && !confirm('Es läuft bereits ein Turnier. Möchtest du ein neues Turnier starten und den aktuellen Fortschritt verwerfen?')) {
                return; // Abbruch, wenn der Benutzer nicht fortfahren möchte
            }

            // UI-Elemente zurücksetzen
            resetTournamentUI();

            // Globale Variablen zurücksetzen
            allPlayers = [];
            groupMatchResults = {};
            knockoutMatches = {};
            tournamentInProgress = false; // Wird erst true, wenn Spieler zugewiesen wurden
            trophyAnimationContainer.classList.remove('active'); // Hide trophy animation

            // Spieler-Eingabebereich leeren und Button aktivieren
            playerNamesInput.value = '';
            assignPlayersButton.disabled = false;
            playerCountSelect.disabled = false; // Spieleranzahl kann wieder geändert werden
            tableCountSelect.disabled = false; // Tischanzahl kann wieder geändert werden

            // alert(`Bereit für ein neues Turnier mit ${numberOfPlayers} Spielern und ${numberOfTables} Tischen!`); // Removed
            toggleSection('playerSetupSection'); // Spieler-Setup öffnen
        }

        /**
         * Setzt alle dynamischen UI-Elemente zurück.
         */
        function resetTournamentUI() {
            allGroupsContainer.innerHTML = ''; // Alle Gruppen entfernen
            knockoutBracketDiv.innerHTML = '<div class="final-winner"><h3>TURNIERSIEGER: <span id="tournament_champion"></span></h3></div>'; // K.O.-Phase zurücksetzen
            tournamentChampionSpan.textContent = ''; // Champion leeren
            assignedPlayerListBody.innerHTML = ''; // Zugewiesene Spielerliste leeren
            // document.getElementById('nextGamesSection').innerHTML = '<p>Aktuell keine ungespielten Matches in der Gruppenphase.</p>'; // Diese Zeile wurde entfernt, da die Sektion entfernt wurde
            qualifyButton.disabled = true; // Qualifizierungsbutton deaktivieren
            trophyAnimationContainer.classList.remove('active'); // Hide trophy animation
        }

        /**
         * Generiert die HTML-Struktur für eine einzelne Gruppe.
         * @param {string} groupLetter - Der Buchstabe der Gruppe (z.B. 'A').
         * @returns {string} Die HTML-String für die Gruppe.
         */
        function generateGroupHTML(groupLetter) {
            return `
                <div>
                    <div class="group-header"><h2>Gruppe ${groupLetter}</h2></div>
                    <div class="group-section">
                        <div class="group-primary-display">
                            <div class="group-matches-list" id="group${groupLetter}_matches_list">
                                <h3>Spiele Gruppe ${groupLetter}</h3>
                            </div>
                            <div class="group-billiard-table" id="group${groupLetter}_billiard_table">
                                <div class="table-title">Aktuelles Spiel auf Tisch ${groupLetter}</div>
                                <div class="player-on-table" id="group${groupLetter}_player1_on_table"></div>
                                <div class="player-on-table" id="group${groupLetter}_player2_on_table"></div>
                            </div>
                        </div>
                        <div class="group-details">
                            <h3>Rangliste Gruppe ${groupLetter}</h3>
                            <table class="group-table" id="group${groupLetter}_ranking">
                                <thead>
                                    <tr>
                                        <th style="width: 50px;">Rang</th>
                                        <th>Spieler</th>
                                        <th>Spiele</th>
                                        <th>Siege</th>
                                        <th>Niederlagen</th>
                                        <th>Frames+</th>
                                        <th>Frames-</th>
                                        <th>Diff.</th>
                                        <th>Punkte</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * Generiert die HTML-Struktur für eine K.O.-Runde.
         * @param {string} roundName - Name der Runde (z.B. "Achtelfinale", "Viertelfinale").
         * @param {number} numMatches - Anzahl der Matches in dieser Runde.
         * @param {string} matchIdPrefix - Präfix für die Match-IDs (z.B. "af", "vf").
         * @returns {string} Die HTML-String für die Runde.
         */
        function generateKnockoutRoundHTML(roundName, numMatches, matchIdPrefix) {
            let matchesHTML = '';
            for (let i = 1; i <= numMatches; i++) {
                const matchId = `${matchIdPrefix}_match${i}`;
                matchesHTML += `
                    <div class="match" id="${matchId}">
                        <div class="match-label">${roundName} ${numMatches > 1 ? i : ''}</div>
                        <div class="player-name" id="${matchIdPrefix}${i}_player1"></div>
                        <div class="vs">vs.</div>
                        <div class="player-name" id="${matchIdPrefix}${i}_player2"></div>
                        <span class="winner result-cell" data-match-id="${matchIdPrefix}${i}"></span>
                    </div>
                `;
            }
            return `
                <div class="round-column">
                    <h3>${roundName}</h3>
                    ${matchesHTML}
                </div>
            `;
        }

        // Funktion zum Parsen eines Ergebnis-Strings (z.B. "3:1")
        function parseResult(resultString) {
            if (!resultString || typeof resultString !== 'string' || !resultString.includes(':')) {
                return { won: 0, lost: 0, isValid: false };
            }
            const parts = resultString.split(':').map(Number);
            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                return { won: parts[0], lost: parts[1], isValid: true };
            }
            return { won: 0, lost: 0, isValid: false };
        }

        /**
         * Generiert einen optimierten Spielplan für eine Gruppe (Round Robin).
         * Priorisiert, dass Spieler nicht direkt aufeinanderfolgende Matches haben.
         * Dies ist eine Heuristik für 4 Spieler (6 Matches).
         * @param {Array<Object>} players - Die Spielerobjekte einer Gruppe.
         * @returns {Array<Object>} Eine geordnete Liste von Match-Objekten.
         */
        function getOptimizedGroupSchedule(players) {
            const p = players.map(player => player.name); // Nur Namen für die Paarungen
            const numPlayers = p.length;
            const matches = [];

            if (numPlayers % 2 !== 0) {
                // Add a "dummy" player for odd numbers to simplify scheduling
                p.push(null);
            }

            const rounds = numPlayers - 1;
            for (let r = 0; r < rounds; r++) {
                for (let i = 0; i < numPlayers / 2; i++) {
                    const player1 = p[i];
                    const player2 = p[numPlayers - 1 - i];
                    if (player1 !== null && player2 !== null) {
                        matches.push({ player1: player1, player2: player2 });
                    }
                }
                // Rotate players (except the first one)
                const lastPlayer = p.pop();
                p.splice(1, 0, lastPlayer);
            }
            return matches;
        }

        /**
         * Richtet Spieler ein und weist sie Gruppen zu.
         * Wird beim Klicken auf "Spieler einrichten aufgerufen.
         */
        function setupPlayersAndGroups() {
            const names = playerNamesInput.value.split('\n').map(name => name.trim()).filter(name => name !== '');

            if (names.length !== numberOfPlayers) {
                alert(`Bitte gib genau ${numberOfPlayers} Spielernamen ein, jeden in einer neuen Zeile.`);
                return;
            }

            // NEU: Überprüfung der Teilbarkeit
            if (numberOfPlayers % numberOfTables !== 0) {
                alert(`Fehler: Die Anzahl der Spieler (${numberOfPlayers}) muss durch die Anzahl der Tische (${numberOfTables}) teilbar sein, um eine gleichmäßige Verteilung zu gewährleisten.`);
                return;
            }

            tournamentInProgress = true;
            assignPlayersButton.disabled = true; // Button deaktivieren, solange Turnier läuft
            playerCountSelect.disabled = true; // Anzahl der Spieler sperren
            tableCountSelect.disabled = true; // Tischanzahl sperren
            trophyAnimationContainer.classList.remove('active'); // Hide trophy animation

            allPlayers = [];
            assignedPlayerListBody.innerHTML = ''; // Liste leeren
            allGroupsContainer.innerHTML = ''; // Alte Gruppen-Container leeren
            groupMatchResults = {}; // Alte Ergebnisse leeren

            // Dynamische Generierung der Gruppenbuchstaben A, B, C...
            groupLetters = [];
            for (let i = 0; i < numberOfTables; i++) {
                groupLetters.push(String.fromCharCode(65 + i)); // 65 ist der ASCII-Code für 'A'
            }
            
            const playersPerGroup = numberOfPlayers / numberOfTables;

            // Spieler den Gruppen zuweisen
            for (let i = 0; i < names.length; i++) {
                const player = { id: i + 1, name: names[i], group: groupLetters[Math.floor(i / playersPerGroup)] };
                allPlayers.push(player);
                const row = assignedPlayerListBody.insertRow();
                row.innerHTML = `<td>${player.id}</td><td>${player.name}</td><td>${player.group}</td>`;
            }

            // Dynamische Gruppensektionen hinzufügen und füllen
            groupLetters.forEach(groupLetter => {
                allGroupsContainer.insertAdjacentHTML('beforeend', generateGroupHTML(groupLetter));
                const groupPlayers = allPlayers.filter(p => p.group === groupLetter);
                
                // Generiere Matches nur, wenn es Spieler in der Gruppe gibt (mindestens 2 für Matches)
                if (groupPlayers.length >= 2) { 
                    groupMatchResults[groupLetter] = getOptimizedGroupSchedule(groupPlayers).map(match => ({ player1: match.player1, player2: match.player2, result: '' }));
                    renderGroupMatches(groupLetter);

                    const rankingTableBody = document.getElementById(`group${groupLetter}_ranking`).querySelector('tbody');
                    rankingTableBody.innerHTML = '';
                    groupPlayers.forEach(player => {
                        const row = rankingTableBody.insertRow();
                        row.setAttribute('data-player-name', player.name);
                        row.innerHTML = `
                            <td class="rank-cell"></td>
                            <td>${player.name}</td>
                            <td class="games-played">0</td>
                            <td class="wins">0</td>
                            <td class="losses">0</td>
                            <td class="frames-plus">0</td>
                            <td class="frames-minus">0</td>
                            <td class="frames-diff">0</td>
                            <td class="points">0</td>
                        `;
                    });
                    updateGroupResults(groupLetter);
                } else { // Wenn weniger als 2 Spieler in einer Gruppe sind
                    document.getElementById(`group${groupLetter}_matches_list`).innerHTML = `<h3>Spiele Gruppe ${groupLetter}</h3><p>Nicht genug Spieler für Matches in dieser Gruppe.</p>`;
                    document.getElementById(`group${groupLetter}_ranking`).querySelector('tbody').innerHTML = `<tr><td colspan="9">${groupPlayers.length === 1 ? groupPlayers[0].name + ' (keine Matches)' : 'Keine Spieler'}</td></tr>`;
                    document.getElementById(`group${groupLetter}_player1_on_table`).textContent = '';
                    document.getElementById(`group${groupLetter}_player2_on_table`).textContent = '';
                }
            });

            // K.O.-Phase dynamisch generieren
            generateKnockoutPhase();
            // updateOverallNextGamesDisplay(); // Diese Funktion wird nicht mehr benötigt
            console.log('Spieler eingerichtet und Gruppen zugewiesen.');
            alert('Spieler eingerichtet und Gruppen zugewiesen! Beginne mit den Gruppenspielen.');
            toggleSection('playerSetupSection'); // Spieler-Setup einklappen
        }

        /**
         * Generiert die K.O.-Phase basierend auf der Anzahl der qualifizierten Spieler.
         * Es qualifizieren sich immer 2 Spieler pro Gruppe.
         */
        function generateKnockoutPhase() {
            knockoutBracketDiv.innerHTML = '<div class="final-winner"><h3>TURNIERSIEGER: <span id="tournament_champion"></span></h3></div>'; // Vorherige K.O.-Struktur leeren
            tournamentChampionSpan.textContent = '';
            knockoutMatches = {}; // K.O.-Matches zurücksetzen
            trophyAnimationContainer.classList.remove('active'); // Hide trophy animation

            let currentKnockoutHTML = '';
            let knockoutTitle = 'K.O.-Phase';
            
            const qualifiedPlayersPerGroup = 2; // Annahme: immer 2 Qualifizierte pro Gruppe
            const totalQualifiedPlayers = numberOfTables * qualifiedPlayersPerGroup;

            if (totalQualifiedPlayers < 2) { // Mindestens 2 Spieler für K.O.-Phase
                knockoutTitle = 'K.O.-Phase (Nicht genug Qualifizierte Spieler)';
                currentKnockoutHTML += '<p>Es gibt nicht genug qualifizierte Spieler für eine K.O.-Phase. Mindestens 2 Qualifikanten benötigt.</p>';
            } else {
                let numRounds = 0;
                let numMatchesInRound = totalQualifiedPlayers / 2;
                let currentRoundPlayers = totalQualifiedPlayers;

                // Bestimme die Anzahl der Runden und Match-IDs
                const rounds = [];
                // Diese Logik sollte hier die gleiche sein wie in qualifyGroupWinners,
                // um Konsistenz zu gewährleisten.
                if (currentRoundPlayers === 2) { // Finale
                    rounds.push({ name: 'Finale', prefix: 'final', matches: 1 });
                } else if (currentRoundPlayers === 4) { // Halbfinale, Finale
                    rounds.push({ name: 'Halbfinale', prefix: 'hf', matches: 2 });
                    rounds.push({ name: 'Finale', prefix: 'final', matches: 1 });
                } else if (currentRoundPlayers === 8) { // Viertelfinale, Halbfinale, Finale
                    rounds.push({ name: 'Viertelfinale', prefix: 'vf', matches: 4 });
                    rounds.push({ name: 'Halbfinale', prefix: 'hf', matches: 2 });
                    rounds.push({ name: 'Finale', prefix: 'final', matches: 1 });
                } else if (currentRoundPlayers === 16) { // Achtelfinale, Viertelfinale, Halbfinale, Finale
                    rounds.push({ name: 'Achtelfinale', prefix: 'af', matches: 8 });
                    rounds.push({ name: 'Viertelfinale', prefix: 'vf', matches: 4 });
                    rounds.push({ name: 'Halbfinale', prefix: 'hf', matches: 2 });
                    rounds.push({ name: 'Finale', prefix: 'final', matches: 1 });
                } else {
                    // Für andere Spielerzahlen, generiere nur "Matches" (ohne spezifische Rundenbezeichnung)
                    knockoutTitle = 'K.O.-Phase';
                    let currentMatches = totalQualifiedPlayers / 2;
                    let roundCounter = 1;
                    while (currentMatches >= 1) {
                        const roundName = currentMatches === 1 ? 'Finale' : (currentMatches === 2 ? 'Halbfinale' : (currentMatches === 4 ? 'Viertelfinale' : (currentMatches === 8 ? 'Achtelfinale' : `Runde ${roundCounter}`)));
                        const prefix = currentMatches === 1 ? 'final' : (currentMatches === 2 ? 'hf' : (currentMatches === 4 ? 'vf' : (currentMatches === 8 ? 'af' : `r${roundCounter}`)));
                        rounds.push({ name: roundName, prefix: prefix, matches: currentMatches });
                        currentMatches = currentMatches / 2;
                        roundCounter++;
                    }
                }

                // Generiere HTML für jede Runde und definiere die knockoutMatches Struktur
                for (let i = 0; i < rounds.length; i++) {
                    const round = rounds[i];
                    currentKnockoutHTML += generateKnockoutRoundHTML(round.name, round.matches, round.prefix);

                    for (let j = 1; j <= round.matches; j++) {
                        const matchId = `${round.prefix}${j}`;
                        let nextPlayerTarget = '';
                        if (i < rounds.length - 1) { // Wenn es eine nächste Runde gibt
                            const nextRound = rounds[i + 1];
                            const nextMatchIndex = Math.ceil(j / 2); // Gewinner geht zum nächsten Match in der nächsten Runde
                            const nextPlayerPosition = (j % 2 === 1) ? 'player1' : 'player2'; // Ungerade Matches füllen player1, gerade Matches füllen player2
                            nextPlayerTarget = `${nextRound.prefix}${nextMatchIndex}_${nextPlayerPosition}`;
                        } else { // Letzte Runde (Finale)
                            nextPlayerTarget = 'tournament_champion';
                        }
                        knockoutMatches[matchId] = { player1: `${round.prefix}${j}_player1`, player2: `${round.prefix}${j}_player2`, nextPlayer: nextPlayerTarget };
                    }
                }
            }

            knockoutBracketDiv.insertAdjacentHTML('afterbegin', currentKnockoutHTML); // Vor dem final_winner einfügen
            document.getElementById('knockoutPhaseTitle').textContent = knockoutTitle;

            // Initialisiere K.O.-Felder mit Event-Listenern
            Object.keys(knockoutMatches).forEach(matchId => {
                const winnerCell = document.querySelector(`.winner.result-cell[data-match-id="${matchId}"]`);
                if (winnerCell) {
                    winnerCell.textContent = '';
                    winnerCell.classList.remove('played');
                    winnerCell.onclick = () => openResultModal(winnerCell, true);
                }
            });
            tournamentChampionSpan.textContent = ''; // Finalen Sieger leeren
            qualifyButton.disabled = false; // Qualifizierungsbutton aktivieren
        }


        /**
         * Rendert die Matches für eine spezifische Gruppe in der Liste.
         * Markiert auch das nächste anstehende Spiel pro Gruppe und aktualisiert den Billardtisch.
         * @param {string} groupId - Die ID der Gruppe (z.B. 'A').
         */
        function renderGroupMatches(groupId) {
            const matchesListDiv = document.getElementById(`group${groupId}_matches_list`);
            // Lösche alle alten Match-Items außer dem H3-Header
            Array.from(matchesListDiv.children).forEach(child => {
                if (child.tagName !== 'H3') {
                    child.remove();
                }
            });

            const matches = groupMatchResults[groupId];
            let foundNextMatch = false; // Flag, um das erste ungespielte Match zu finden
            let nextPlayer1 = '';
            let nextPlayer2 = '';

            matches.forEach((match, index) => {
                const matchItem = document.createElement('div');
                matchItem.classList.add('group-match-item');

                if (match.result !== '') {
                    matchItem.classList.add('played');
                } else if (!foundNextMatch) { // Markiere das erste ungespielte Match als "next-up"
                    matchItem.classList.add('next-up');
                    foundNextMatch = true;
                    nextPlayer1 = match.player1;
                    nextPlayer2 = match.player2;
                }

                matchItem.innerHTML = `
                    <span class="players">${match.player1} vs. ${match.player2}</span>
                    <span class="result-display" data-group="${groupId}" data-match-index="${index}">${match.result}</span>
                `;

                // Füge Event Listener direkt zum result-display Span hinzu
                matchItem.querySelector('.result-display').onclick = (event) => {
                    const targetCell = event.currentTarget;
                    openResultModal(targetCell, false);
                };
                matchesListDiv.appendChild(matchItem);
            });

            // Aktualisiere den virtuellen Billardtisch für diese Gruppe
            document.getElementById(`group${groupId}_player1_on_table`).textContent = nextPlayer1;
            document.getElementById(`group${groupId}_player2_on_table`).textContent = nextPlayer2;

            if (!foundNextMatch) { // Wenn alle Matches gespielt sind, den Tisch leeren
                document.getElementById(`group${groupId}_player1_on_table`).textContent = '';
                document.getElementById(`group${groupId}_player2_on_table`).textContent = '';
            }
        }

        /**
         * Öffnet das Modal zur Ergebniseingabe.
         * @param {HTMLElement} cell - Die angeklickte Ergebnis-Zelle oder das Ergebnis-Display-Span.
         * @param {boolean} isKo - True, wenn es sich um ein K.O.-Match handelt, sonst false.
         */
        function openResultModal(cell, isKoMatch) {
            currentResultCell = cell; // Die aktuelle Zelle speichern
            isKnockoutModal = isKoMatch;
            selectedKnockoutWinner = ''; // Zurücksetzen der Auswahl

            const groupPhaseScoreInput = document.getElementById('groupPhaseScoreInput');
            const knockoutWinnerSelection = document.getElementById('knockoutWinnerSelection');
            const score1Input = document.getElementById('score1');
            const score2Input = document.getElementById('score2');
            let player1Name, player2Name;

            if (isKoMatch) {
                const matchId = cell.dataset.matchId;
                const matchData = knockoutMatches[matchId];

                // Sicherstellen, dass die Spieler-IDs im matchData Objekt existieren und gültig sind
                const player1Element = document.getElementById(matchData.player1);
                const player2Element = document.getElementById(matchData.player2);

                player1Name = player1Element ? player1Element.textContent : '';
                player2Name = player2Element ? player2Element.textContent : '';

                // Wenn Spieler noch nicht qualifiziert sind, Modal nicht öffnen
                if (!player1Name || !player2Name) {
                    alert('Spieler für dieses K.O.-Match noch nicht qualifiziert.');
                    return;
                }

                // Zeige K.O.-Spezifische Auswahl und verstecke Score-Eingabe
                groupPhaseScoreInput.style.display = 'none';
                knockoutWinnerSelection.style.display = 'flex';

                const winnerOption1 = document.getElementById('winnerOption1');
                const winnerOption2 = document.getElementById('winnerOption2');

                winnerOption1.textContent = player1Name;
                winnerOption1.dataset.winner = player1Name;
                winnerOption1.classList.remove('selected');

                winnerOption2.textContent = player2Name;
                winnerOption2.dataset.winner = player2Name;
                winnerOption2.classList.remove('selected');

                document.getElementById('winnerOptionNone').classList.remove('selected'); // Reset 'No winner' selection
            } else {
                const groupId = cell.dataset.group;
                const matchIndex = parseInt(cell.dataset.matchIndex);
                const match = groupMatchResults[groupId][matchIndex];
                player1Name = match.player1;
                player2Name = match.player2;

                // Verstecke K.O.-Spezifische Auswahl und zeige Score-Eingabe
                groupPhaseScoreInput.style.display = 'flex';
                knockoutWinnerSelection.style.display = 'none';

                // Setze die aktuellen Ergebnisse im Modal, falls vorhanden
                const currentResult = parseResult(match.result);
                score1Input.value = currentResult.won;
                score2Input.value = currentResult.lost;
            }

            document.getElementById('modalPlayer1').textContent = player1Name;
            document.getElementById('modalPlayer2').textContent = player2Name;
            document.getElementById('resultModal').style.display = 'flex';
        }

        /**
         * Schließt das Modal.
         */
        function closeModal() {
            document.getElementById('resultModal').style.display = 'none';
        }

        /**
         * Ändert den Score-Wert in der Modal-Eingabe.
         * @param {string} scoreId - Die ID des Score-Inputs ('score1' oder 'score2').
         * @param {number} delta - Der Wert, um den der Score geändert werden soll (-1 oder 1).
         */
        function changeScore(scoreId, delta) {
            const scoreInput = document.getElementById(scoreId);
            let currentValue = parseInt(scoreInput.value);
            scoreInput.value = Math.max(0, currentValue + delta); // Score nicht unter 0
        }

        /**
         * Speichert das Ergebnis aus dem Modal.
         */
        function saveResultFromModal() {
            if (isKnockoutModal) {
                saveKnockoutResult();
            } else {
                saveGroupPhaseResult();
            }
            closeModal();
            // updateOverallNextGamesDisplay(); // Diese Funktion wird nicht mehr benötigt
        }

        /**
         * Speichert das Ergebnis eines Gruppenspiels.
         */
        function saveGroupPhaseResult() {
            const score1 = document.getElementById('score1').value;
            const score2 = document.getElementById('score2').value;
            const result = `${score1}:${score2}`;

            const groupId = currentResultCell.dataset.group;
            const matchIndex = parseInt(currentResultCell.dataset.matchIndex);

            groupMatchResults[groupId][matchIndex].result = result;
            renderGroupMatches(groupId); // Gruppenansicht aktualisieren
            updateGroupResults(groupId); // Ranking aktualisieren
        }

        /**
         * Speichert das Ergebnis eines K.O.-Matches.
         */
        function saveKnockoutResult() {
            const matchId = currentResultCell.dataset.matchId;
            const matchInfo = knockoutMatches[matchId];

            const player1Name = document.getElementById(matchInfo.player1).textContent;
            const player2Name = document.getElementById(matchInfo.player2).textContent;

            // Wenn "Kein Gewinner" gewählt wurde, setze das Match zurück
            if (selectedKnockoutWinner === 'Kein Gewinner') {
                currentResultCell.textContent = '';
                currentResultCell.classList.remove('played');
                // Setze die Spieler der nächsten Runde zurück
                if (matchInfo.nextPlayer) {
                    const nextPlayerElement = document.getElementById(matchInfo.nextPlayer);
                    if (nextPlayerElement) {
                        nextPlayerElement.textContent = '';
                    }
                }
                // Bei Final-Reset, Turniersieger leeren und Trophäenanimation verstecken
                if (matchId === 'final') {
                    document.getElementById('tournament_champion').textContent = '';
                    trophyAnimationContainer.classList.remove('active');
                }
                alert('Match-Ergebnis zurückgesetzt.');
                return;
            }

            // Stelle sicher, dass ein Gewinner ausgewählt wurde
            if (!selectedKnockoutWinner) {
                alert('Bitte wähle einen Gewinner aus.');
                return;
            }

            // Setze den Gewinner in die Zelle
            currentResultCell.textContent = selectedKnoutWinner;
            currentResultCell.classList.add('played');

            // Wenn es nicht das Finale ist, rücke den Gewinner in die nächste Runde vor
            if (matchInfo.nextPlayer && matchInfo.nextPlayer !== 'tournament_champion') {
                const nextPlayerElement = document.getElementById(matchInfo.nextPlayer);
                if (nextPlayerElement) {
                    nextPlayerElement.textContent = selectedKnockoutWinner;
                    // Wenn der nächste Spieler gesetzt wird, stelle sicher, dass die zugehörige Gewinner-Zelle leer und klickbar ist
                    const nextMatchId = nextPlayerElement.id.substring(0, nextPlayerElement.id.indexOf('_player')); // z.B. hf1
                    const nextWinnerCell = document.querySelector(`.winner.result-cell[data-match-id="${nextMatchId}"]`);
                    if (nextWinnerCell) {
                        nextWinnerCell.textContent = ''; // Leeren, falls schon ein Platzhalter drin war
                        nextWinnerCell.classList.remove('played'); // Entfernen der "gespielt"-Klasse
                        nextWinnerCell.onclick = () => openResultModal(nextWinnerCell, true); // Klickbar machen
                    }
                }
            } else if (matchInfo.nextPlayer === 'tournament_champion') {
                document.getElementById('tournament_champion').textContent = selectedKnockoutWinner;
                // Show trophy animation
                animatedWinnerName.textContent = selectedKnockoutWinner;
                trophyAnimationContainer.classList.add('active');
                // Removed the setTimeout to hide, now it only hides on click.
            }
        }

        /**
         * Wählt den Gewinner im K.O.-Modal aus.
         * @param {HTMLElement} element - Das angeklickte Gewinner-Option-Element.
         * @param {boolean} reset - True, wenn das Match zurückgesetzt werden soll.
         */
        function selectWinner(element, reset = false) {
            // Alle Optionen deselektieren
            document.querySelectorAll('.knockout-winner-selection .winner-option').forEach(opt => {
                opt.classList.remove('selected');
            });

            // Aktuelle Option auswählen
            if (!reset) {
                element.classList.add('selected');
                selectedKnockoutWinner = element.dataset.winner;
            } else {
                selectedKnockoutWinner = 'Kein Gewinner'; // Spezieller Wert für Reset
            }
        }


        /**
         * Aktualisiert die Rangliste und Punkte für eine Gruppe.
         * @param {string} groupId - Die ID der Gruppe (z.B. 'A').
         */
        function updateGroupResults(groupId) {
            const groupPlayers = allPlayers.filter(p => p.group === groupId);
            const matches = groupMatchResults[groupId];

            // Statistiken für jeden Spieler zurücksetzen
            groupPlayers.forEach(player => {
                player.gamesPlayed = 0;
                player.wins = 0;
                player.losses = 0;
                player.framesPlus = 0;
                player.framesMinus = 0;
                player.frameDiff = 0;
                player.points = 0;
            });

            // Ergebnisse der Matches verarbeiten
            matches.forEach(match => {
                if (match.result) {
                    const result = parseResult(match.result);
                    if (result.isValid) {
                        const player1 = groupPlayers.find(p => p.name === match.player1);
                        const player2 = groupPlayers.find(p => p.name === match.player2);

                        if (player1 && player2) {
                            player1.gamesPlayed++;
                            player2.gamesPlayed++;

                            player1.framesPlus += result.won;
                            player1.framesMinus += result.lost;
                            player2.framesPlus += result.lost;
                            player2.framesMinus += result.won;

                            if (result.won > result.lost) {
                                player1.wins++;
                                player2.losses++;
                                player1.points += 2;
                            } else if (result.lost > result.won) {
                                player2.wins++;
                                player1.losses++;
                                player2.points += 2;
                            }
                            // Unentschieden sind im Billard eher unüblich, aber könnten hier behandelt werden (z.B. 1 Punkt pro Spieler)
                        }
                    }
                }
            });

            // Frame-Differenz berechnen
            groupPlayers.forEach(player => {
                player.frameDiff = player.framesPlus - player.framesMinus;
            });

            // Spieler nach Punkten, dann Frame-Differenz, dann Frames+ sortieren
            groupPlayers.sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                if (b.frameDiff !== a.frameDiff) return b.frameDiff - a.frameDiff;
                return b.framesPlus - a.framesPlus;
            });

            // Rangliste aktualisieren
            const rankingTableBody = document.getElementById(`group${groupId}_ranking`).querySelector('tbody');
            rankingTableBody.innerHTML = ''; // Vorherige Einträge löschen

            groupPlayers.forEach((player, index) => {
                const row = rankingTableBody.insertRow();
                row.setAttribute('data-player-name', player.name);
                row.innerHTML = `
                    <td class="rank-cell">${index + 1}</td>
                    <td>${player.name}</td>
                    <td class="games-played">${player.gamesPlayed}</td>
                    <td class="wins">${player.wins}</td>
                    <td class="losses">${player.losses}</td>
                    <td class="frames-plus">${player.framesPlus}</td>
                    <td class="frames-minus">${player.framesMinus}</td>
                    <td class="frames-diff">${player.frameDiff}</td>
                    <td class="points">${player.points}</td>
                `;
            });
            checkGroupCompletion(groupId); // Prüfen, ob die Gruppe abgeschlossen ist
        }

        /**
         * Überprüft, ob alle Gruppenspiele abgeschlossen sind und aktualisiert den Qualifizierungsbutton.
         * @param {string} groupId - Die ID der Gruppe.
         */
        function checkGroupCompletion(groupId) {
            const matches = groupMatchResults[groupId];
            const allGroupMatchesPlayed = matches.every(match => match.result !== '');

            // Überprüfe, ob ALLE Gruppen abgeschlossen sind
            const allGroupsCompleted = groupLetters.every(gId => groupMatchResults[gId] && groupMatchResults[gId].every(match => match.result !== ''));

            if (allGroupsCompleted) {
                qualifyButton.disabled = false;
                alert('Alle Gruppenspiele sind abgeschlossen! Du kannst nun die qualifizierten Spieler zur K.O.-Phase hinzufügen.');
            } else {
                qualifyButton.disabled = true; // Deaktivieren, wenn nicht alle Gruppen fertig sind
            }
        }

        /**
         * Fügt die qualifizierten Spieler zur K.O.-Phase hinzu.
         * Die ersten 2 Spieler jeder Gruppe qualifizieren sich.
         */
        function qualifyGroupWinners() {
            if (!confirm('Möchtest du die qualifizierten Spieler (Platz 1 & 2 jeder Gruppe) zur K.O.-Phase hinzufügen? Dies kann nicht rückgängig gemacht werden.')) {
                return;
            }

            let qualifiedPlayers = [];
            groupLetters.forEach(groupLetter => {
                const groupPlayers = allPlayers.filter(p => p.group === groupLetter);
                // Sortiere neu, um sicherzustellen, dass die Rangliste aktuell ist
                groupPlayers.sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    if (b.frameDiff !== a.frameDiff) return b.frameDiff - a.frameDiff;
                    return b.framesPlus - a.framesPlus;
                });
                // Füge die ersten 2 Spieler hinzu
                if (groupPlayers.length >= 2) { // Stelle sicher, dass genug Spieler vorhanden sind
                    qualifiedPlayers.push(groupPlayers[0].name);
                    qualifiedPlayers.push(groupPlayers[1].name);
                } else if (groupPlayers.length === 1) {
                    // Wenn nur ein Spieler in der Gruppe ist, wird dieser qualifiziert
                    qualifiedPlayers.push(groupPlayers[0].name);
                }
                // Wenn 0 Spieler, dann nichts hinzufügen
            });

            // Spieler zufällig mischen, um faire K.O.-Paarungen zu gewährleisten
            qualifiedPlayers.sort(() => Math.random() - 0.5);

            const qualifiedPlayersPerGroup = 2; // Annahme: immer 2 Qualifizierte pro Gruppe
            const totalQualifiedPlayers = numberOfTables * qualifiedPlayersPerGroup;

            // NEU: Bestimme die Rundenstruktur hier erneut, um Konsistenz mit generateKnockoutPhase zu gewährleisten
            const rounds = [];
            let currentMatches = totalQualifiedPlayers / 2;
            let roundCounter = 1;
            while (currentMatches >= 1) {
                const roundName = currentMatches === 1 ? 'Finale' : (currentMatches === 2 ? 'Halbfinale' : (currentMatches === 4 ? 'Viertelfinale' : (currentMatches === 8 ? 'Achtelfinale' : `Runde ${roundCounter}`)));
                const prefix = currentMatches === 1 ? 'final' : (currentMatches === 2 ? 'hf' : (currentMatches === 4 ? 'vf' : (currentMatches === 8 ? 'af' : `r${roundCounter}`)));
                rounds.push({ name: roundName, prefix: prefix, matches: currentMatches });
                currentMatches = currentMatches / 2;
                roundCounter++;
            }

            if (rounds.length === 0) {
                alert('Es wurde keine K.O.-Phase generiert oder es gibt nicht genug qualifizierte Spieler.');
                return;
            }

            // NEU: Verwende den Präfix der ersten Runde aus der generierten Rundenstruktur
            const firstRoundPrefix = rounds[0].prefix;
            
            const initialMatches = Object.keys(knockoutMatches).filter(key => key.startsWith(firstRoundPrefix));

            if (initialMatches.length * 2 !== qualifiedPlayers.length) {
                alert(`Fehler: ${qualifiedPlayers.length} qualifizierte Spieler können nicht in ${initialMatches.length} Start-Matches der K.O.-Phase aufgeteilt werden. Benötige ${initialMatches.length * 2} Spieler.`);
                qualifyButton.disabled = false; // Button wieder aktivieren, falls Fehler
                return;
            }

            let playerIndex = 0;
            initialMatches.forEach(matchKey => {
                const matchData = knockoutMatches[matchKey];
                document.getElementById(matchData.player1).textContent = qualifiedPlayers[playerIndex++];
                document.getElementById(matchData.player2).textContent = qualifiedPlayers[playerIndex++];
            });

            qualifyButton.disabled = true; // Button deaktivieren, nachdem Spieler qualifiziert wurden
            alert('Qualifizierte Spieler wurden zur K.O.-Phase hinzugefügt!');
            // toggleSection('nextGamesSectionWrapper'); // Diese Zeile wurde entfernt, da die Sektion entfernt wurde
            document.getElementById('knockoutPhaseTitle').scrollIntoView({ behavior: 'smooth' }); // Zum K.O.-Bereich scrollen
        }

        // Service Worker Registrierung für PWA (unverändert)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registriert mit Scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.error('ServiceWorker Registrierung fehlgeschlagen: ', error);
                    });
            });
        }
    </script>
</body>
</html>